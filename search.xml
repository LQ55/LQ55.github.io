<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javaScript通过原型链实现继承]]></title>
    <url>%2F2018%2F08%2F13%2FjavaScript%E9%80%9A%E8%BF%87%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[借用构造函数实现继承 12345678910function SuperType()&#123; this.colors = ["red","blue","green"];&#125;function SubType()&#123; //在子类构造函数中调用父类构造函数（同时这种方式支持向父类构造函数传参） SuperType.call(this); //SuperType.call(this,arg1,arg2) //SuperType.apply(this,args)&#125; 作用：借用构造函数方式是在新的SubType对象上面执行SuperType中定义的初始化代码，针对在原型中的引用类型，每一个实例都有自己的一个副本（可以清除原型中包含引用类型值的问题） 问题：仅仅是借用构造函数，无法避免构造函数模式存在的问题，方法都是在构造函数中定义，因此函数复用就无从谈起了 组合继承(经典继承) 这种方式的思想是使用原型实现对原型属性和方法的继承，而通过构造函数实现对实例属性的继承 123456789101112131415161718192021function SuperType(name)&#123; this.name = name; this.colors = ["red","blue","green"];&#125;//父类原型的属性和方法SuperType.prototype.SayName = function()&#123; alert(this.name);&#125;function SubType(name,age)&#123; //通过调用父类的构造方法继承父类的实例属性 SuperType.call(this,name); //自己的实例属性 this.age = age;&#125;//通过原型方式继承父类SubType.prototype = new SuperType();//重写constructor属性SubType.prototype.constructor = SubType;SubType.ptototype.sayAge = function()&#123; alert(this.age);&#125; 组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，是javaScript中最常用的一种继承模式。 问题：组合继承会导致父类构造方法被调用两次，当我们在创建子类原型的时候会调用一次，第二次是我们调用子类构造方法的时候里面会调用一次。 原型式继承 借助原型可以基于已有对象创建新的对象，同时还不必因此创建自定义类型 1234567891011121314151617181920212223var person = &#123; name:"SC", friends:["nix","unix","windows","ubantu"]&#125;function object(o)&#123; //临时构造函数 function F()&#123;&#125;; //继承 F.prototype = o; return new F();&#125;var p1 = object(person);p1.friends.push("p1's friends");p1.name = "P1";var p2 = object(person);p2.friends.push("p2's friends");p2.name = "P2";console.log(p1.name);//P1console.log(p2.name);//P2console.log(p1.friends);//["nix", "unix", "windows", "ubantu", "p1's friends", "p2's friends"]console.log(p2.friends);//["nix", "unix", "windows", "ubantu", "p1's friends", "p2's friends"] 上面的原型方式在ECMScript5中通过新增Object.create()方法规范化了，该方法接收两个参数，第一个为用作新对象原型的对象和（可选的）一个新对象定义额外属性的对象。 问题：原型式继承同样没有解决引用问题 寄生式继承 寄生式继承思路与寄生构造函数类似，也就是创建一个仅仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再像真正的地是它做了所有的工作一样返回对象。 1234567891011//寄生式继承function createAnother(original)&#123; //调用函数创建一个新的对象 var clone = object(original); //以某种方式来增强这个对象 clone.sayHi = function()&#123; alert("HI"); &#125; return clone;&#125;//上面的object()函数不是必须的，每一个能够返回新对象的函数都可以适用这个模式 问题：可以使用寄生继承来为对象添加函数，会由于不能做到函数复用而降低效率，这一点会与构造函数模式类似。 寄生组合式继承 寄生组合式继承解决组合继承中两次调用父类构造函数的问题。寄生组合式继承，也就是通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 思路是：不必为了指定子类的原型而调用超类的构造函数，我们所需要的无非就是超类型原型的一个副本而已，本质上，就是使用寄生继承来继承超类原型，然后再将结果指定给子类型的原型 123456789function inheritPrototype(subType,superType)&#123; //创建对象 var prototype = object(superType.prototype); //增强对象 prototype.constructor = subType; //指定对象 subType.prototype = prototype;&#125;]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LESS学习笔记]]></title>
    <url>%2F2018%2F08%2F13%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[LESS学习笔记Less是一门CSS预处理语言，它扩展了CSS，增加了变量、Mixin、函数等特性，使得CSS更加易于维护和扩展。Less可以运行在Node或者浏览器环境。 Less嵌套规则 Less支持嵌套规则，style.less文件内容如下： 1234567891011.container&#123; .header&#123; border:1px solid red; &#125; .body&#123; height:400px; .header&#123; background:red; &#125; &#125;&#125; 运行lessc style.less style.css命令编译后 123456789.container .header &#123; border: 1px solid red;&#125;.container .body &#123; height: 400px;&#125;.container .body .header &#123; background: red;&#125; Less操作 LESS支持一些算术运算，例如加号(+)，减号( - )，乘法(*)和除法(/)，它们可以对任何数字，颜色或变量进行操作。 12345@fontSize: 10px;.myclass &#123; font-size: @fontSize * 2;/*编译后，这里会变成font-size:20px*/ color:green;&#125; Less转义 它动态构建选择器，并使用属性或变量值作为任意字符串。 123p &#123; color: ~"green";/*经过转义，变成color:green*/&#125; 在将LESS代码编译为CSS代码之后，〜“some_text”中的任何内容将显示为 some_text Less函数 LESS映射具有值操作的JavaScript代码，并使用预定义的函数来操纵样式表中的HTML元素。 它提供了操作颜色的几个功能，如圆函数，floor函数，ceil函数，百分比函数等。 123456@color: #FF8000;@width:1.0;.mycolor&#123; color: @color; width: percentage(@width);/*这里的函数percentage是百分比函数，转化后为width:100%;*/&#125; Less变量范围 变量范围指定可用变量的位置。 变量将从本地作用域搜索，如果它们不可用，则编译器将从父作用域搜索。 （从子到父） 1234567@var: @a;@a: 15px;.myclass &#123; font-size: @var; @a:20px; color: green;&#125; 转化后的css代码 1234.myclass &#123; font-size: 20px; color: green;&#125; Less导入 通过@import “less或者css路径” 导入less或者css，下面是myfile.less 123456.myclass&#123; color: #FF8000;&#125;.myclass1&#123; color: #5882FA;&#125; 在style.less中使用@import “/myfile.less”导入myfile.less的内容 12345@import "/myfile.less";.myclass2&#123;color: #FF0000;&#125; 最后通过编译后得到结果如下： 123456789.myclass &#123; color: #FF8000;&#125;.myclass1 &#123; color: #5882FA;&#125;.myclass2 &#123; color: #FF0000;&#125; Less变量 Less定义变量的语法为 ：@变量名称:变量值 1、变量插值（就是将表达式中的变量替换为变量值的过程） 变量插值是评估包含一个或多个变量的表达式或文字的过程，产生其中变量用其对应值替换的输出。 便改良使用的地方有：选择器名称，属性名称，URL和@import语句。 （1）变量用于less选择器 选择器可以引用任何变量，它是在编译时构建的。 变量名称必须放在用@符号前缀的花括号（{}）内。 1234@selector:h2;@&#123;selector&#125; &#123; background:#2ECCFA;&#125; （2）变量用于less URL 变量可以用于保存URL，如下所示 12345@images:"http://www.w3school.cn";.container&#123; background:url("@&#123;images&#125;/less/images/less_variables/birds.jpg"); /*这里编译后为：background:url("http://www.w3school.cn/less/images/less_variables/birds.jpg")*/&#125; （3）变量用于less import语句 import语句可以具有保存路径的变量。当你引用一个普通的父目录时，这是非常有用的。 12345@basePath:"//www.w3school.cn/less";/*这里的变量用于保存一个基础路径*/@import "@&#123;basePath&#125;/external1.less";/*在@import 与语句中引用basePath变量*/.container&#123; background:red;&#125; （4）变量可以由属性引用 变量可以由属性引用。 使用由属性引用的变量的例子 1234@my-property:color;.container&#123; background-@&#123;my-property&#125;:#81F7D8;/*经过编译形成的结果为：background-color: #81F7D8;*/&#125; 2、变量名称 可以定义变量名称由一个值组成的变量，下面的就是使用变量保存另外一个变量 12345.container&#123; @col:blue; @color:"col"; background-color:@@color;/*这里的color就@color就保存了另外一个变量的名称，所以通过@color取出名称col，然后又加一个@从col中取值*/&#125; 3、延迟加载 在延迟加载中，即使它们尚未声明，也可以使用变量 123456.container&#123; font-size:@size;/*虽然@size在后面声明的，但是这里依然可以使用，最终为font-size:14px;*/ color:red;&#125;@size:@b;@b:14px; 4、默认值 默认变量只有在尚未设置时才能设置变量。此功能不是必需的，因为变量可以很容易地通过定义它们后覆盖。 后面定义的变量会覆盖前面申明的相同名称的变量。 12345@import "//www.w3cschool.cn/less/lib.less"; //第一次声明变量 @color，@color: green; // 在这里申明了一个和引入的.less文件相同的变量，这里会覆盖前面的p&#123; color : @color;&#125; Less扩展 :extend Extend是一个less伪类，他将所放置它的选择器与匹配引用的选择器进行合并，通过使用:extend选择器在一个选择器中扩展其它选择器样式，示例如下： 1234567.container&#123;// .container 所放置它的选择器 &amp;:extend(.style);//.style 匹配引用的选择器 font-style:italic;&#125;.style&#123; background:green;&#125; 经过编译后转换为css文件为 123456.container&#123; font-style:italic;&#125;.container,.style&#123; background:green;&#125; 通常Less扩展语法有如下一些：扩展附加到选择器、扩展内部规则集、扩展嵌套选择器、完全匹配与扩展、nth表达式、扩展”all”、选择器插值扩展、@media中的范围/扩展、重复检测。 （1）扩展连接到一个选择器 它看起来类似于具有选择器作为参数的伪类。 当规则集具有许多选择器时，则关键字扩展可以应用于任何选择器。 下面是定义代码中extend的格式 在选择器之后扩展。 [例如：pre:hover:extend(div pre)] 允许选择器和扩展之间的空格[例如：pre:hover :extend(div pre)] 允许多个扩展。[例如：pre:hover:extend(div pre):extend(.bucket tr)或者pre:hover:extend(div pre,.bucket tr)] 扩展必须在选择器的末尾定义。pre:hover:extend(div pre) .nth-child(odd)类型不允许 一个扩展连接到选择器的例子： 123456.style,container:extend(.img)&#123; background:red;&#125;.img&#123; font-size:20px;&#125; 上面代码经过编译以后得到如下结果（对.containe进行了扩展） 12345678.style,.container &#123; background: red;&#125;.img,.container &#123;/*这是对.container的扩展后的结果*/ font-size: 20px;&#125; （2）Less扩展内部规则集&amp;:extend &amp;:extend(selector)语法可以放在规则集的正文中。它是放置扩展到规则集的每个选择器的快捷方式。 123456.container,.style&#123; &amp;:extend(.img);&#125;.img&#123; font-style:italic;&#125; 扩展后编译的结果为 12345.img,.container,.style &#123; font-style: italic;/*.container和.style都扩展了.img的规则集*/&#125; （3）Less完全匹配与扩展 默认情况下， extend 查找选择器之间的完全匹配。 对于具有相同含义的两个第n个表达式，扩展无关紧要，但它只寻找与为选择器匹配定义的相同的顺序形式。 1234567.style h3,h3 .style&#123; color: #BF70A5; font-style: italic;&#125;.img:extend(.style h3)&#123;/*如果这里再加一个扩展.img:extend(.tyle h3):extend(h3 .style) 那么编译后.img会出现两次，并且h3 .style需要与前面的选择器完全匹配，如果前面的选择器中间没有空格，也就是h3.style，那么扩展操作里面也不应该有空格，不然会找不到扩展的选择器*/&#125; 编译后的结果为 123456.style h3,h3 .style,.img &#123; color: #BF70A5; font-style: italic;&#125; （4）Less的nth表达式 nth表达式的形式在扩展中很重要，否则它将选择器视为不同。 nth表达式1n + 2和n + 2是等效的，但扩展将该表达式视为不同。 1234:nth-child(n+2)&#123; color:red;&#125;.child:extend(:nth-child(n+2))&#123;&#125;;/*如果这里使用:nth-child(1n+2)，编译的时候会报:nth-child(1n+2)没有找到*/ 在属性选择器中，引用类型不重要，你可以在下面示例中看到他 123456789101112[title=tutorialspoint]&#123; font-size:12px;&#125;[title='tutorialspoint'] &#123; font-style: italic;&#125;[title="tutorialspoint"] &#123; font-style: italic;&#125;.style:extend([title=tutorialspoint]) &#123;&#125;.container:extend([title='tutorialspoint']) &#123;&#125;.img:extend([title="tutorialspoint"]) &#123;&#125; 编译后的结果为 123456789101112131415161718[title=tutorialspoint],.style,.container,.img &#123; font-size: 12px;&#125;[title='tutorialspoint'],.style,.container,.img &#123; font-style: italic;&#125;[title="tutorialspoint"],.style,.container,.img &#123; font-style: italic;&#125; （5）LESS 扩展“all” 当最后在扩展参数中标识关键字 all 时，LESS将该选择器作为另一个选择器的一部分。 匹配的选择器部分将被extend替换，形成一个新的选择器。 （理解起来有点困难，直接上代码） 123456789101112a&#123; background-color: #fff; &amp;:extend(.b all);&#123;/*当在less的继承关系中，需要伪类的时候 可以使用&amp; 表示自己，这里就是表示a，否则默认是表示子代；有 &amp; 时解析的是同一个元素或此元素的伪类，没有 &amp; 解析是后代元素*/ border-bottom: 2px;&#125;.b&#123; font-weight: 700; color: yellow;&#125;.b:hover&#123; font-size: 2em;&#125; 编译后的代码为： 123456789101112a&#123; background-color:#fff; border-bottom:2px;&#125;/*扩展将.b的所有扩展到a中*/.b,a&#123; font-weight: 700; color: yellow;&#125;a:hover,.b:hover&#123; font-size: 2em;&#125; （6）LESS 选择器插值扩展 @ {variable} 符号用作变量名，id和类名的一部分。 扩展不具有使选择器与变量匹配的能力。 扩展可以连接到内插选择器。 123456.style &#123; color: #BF70A5; font-style: italic;&#125;@&#123;variable&#125;:extend(.style) &#123;&#125;@variable: .selector; 编译后的结果为： 12345.style,.selector &#123; color: #BF70A5; font-style: italic;&#125; LESS 重复检测：它不能检测选择器的重复。 LESS混合（相当于编程语言中的函数） 语法为 .函数名(){规则列表} 或者 #函数名(){规则列表} 混合类似于编程语言中的函数。 Mixins是一组CSS属性，允许您将一个类的属性用于另一个类，并且包含类名作为其属性。 在LESS中，可以使用类或id选择器以与CSS样式相同的方式声明mixin。 它可以存储多个值，并且可以在必要时在代码中重复使用。 下面说明LESS mixin的简单使用 （1）不输出mixin 可以创建一个mixin，它可以通过简单地放置括号后在输出中消失。 如下所示 1234567.a()&#123; padding-left:100px;&#125;.container&#123; border:1px solid red; .a();/*这里直接放置.a也能够达到效果（reason?）*/&#125; 变异的结果为 1234.container&#123; border:1px solid red; padding-left:100px;&#125; （2）Less Mixins中的选择器 minxins不仅可以包含属性，还可以包含选择器 12345678#mixin()&#123; &amp;:hover&#123; background:red; &#125;&#125;a&#123; #mixin();&#125; 编译后的结果为 123a:hover &#123; background: red;&#125; （3）Less Mixin命名空间 命名空间用于在通用名称下对mixin进行分组。 使用命名空间可以避免名称冲突，并从外部封装mixin组。示例如下： 123456789#outer()&#123; background:yellow; .inner&#123; color:red; &#125;&#125;p&#123; #outer &gt; .inner;&#125; 编译后的结果为 1234p &#123;color: red;&#125;/*当然如果上面的p里面如果不是获取.inner，直接写#outer的话，结果将会是下面的样子*/p&#123;background:yellow&#125;p .inner&#123;color:red&#125; （4）LESS保护的命名空间 当guard应用于命名空间时，只有在guard条件返回true时才使用由命名空间定义的mixin。 命名空间防护类似于mixins上的guard。 123456789@import "./lib.less";/*lib.less中的内容是拥有一个变量@color:blue*/#namespace when (@color = blue)&#123;//当这里满足条件的时候，才使用命名空间#namespace中定义的mixin .mixin()&#123; color:red; &#125;&#125;p&#123; #namespace .mixin();&#125; 编译后的结果为： 1p&#123;color:red;&#125; （5）LESS !important 关键字 ！important 关键字用于覆盖特定属性。 当它在mixin调用之后放置时，它会将所有继承的属性标记为！important 。 12345678910.mixin()&#123; color: #900; border:1px solid red;&#125;.para1&#123; .mixin();&#125;.para2&#123; .mixin() !important;&#125; 编译后的结果为： 12345678.para1&#123; color:#900;18581203068 border:1px solid red;&#125;.para2&#123; color:#900 !important; border:1px solid red !important;&#125; Less混合参数 （1）Mixins具有多个参数 参数可以使用逗号或分号分隔。 使用逗号符号，可以将其解释为mixin参数分隔符或css列表分隔符。 如果在mixin中使用分号，那么它将用分号分隔参数，CSS列表将包含所有逗号。两种使用方式如下： 如果你有两个参数，那么它们将包含逗号分隔的列表。 例如 .class1(1，2，3; sometext，other thing)。 如果有三个参数，并且只包含数字，例如 .class1(1，2，3)。 您可以使用带有逗号分隔列表的虚拟分号，例如 .class1(1，2，3;)。 有逗号分隔的默认值。 例如 .class1(@color：gray，green;) 用法如下： 12345678910.mixin(@color)&#123; color:@color;&#125;.mixin(@color;@padding:2)&#123; color:@color; padding: @padding;&#125;.container&#123; .mixin(#fff);&#125; 编译后的结果为： 1234.container &#123; color: #fff; padding: 2;&#125; （2）通过命名参数提供值 Mixins通过使用它们的名称提供参数值而不是位置。 参数没有放置值的任何顺序，它们可以通过名称引用。 命名参数的结果更容易阅读，并提供清晰的代码。 如下所示： 12345678910.mixin(@color:black;@fontSize:10px)&#123; color:@color; font-size:@fontSize;&#125;.sx1&#123; .mixin(@font-size:20px;@color:#F59D0);&#125;.sx2&#123; .mixin(#F79F81; @fontSize: 20px);&#125; （3）@argument变量传递了所有的参数。 当不想使用单个参数时， @arguments 变量很有用。 如下： 12345678.box-shadow(@x: 0; @y: 0; @height: 3px; @width: 3px) &#123; -webkit-box-shadow: @arguments;/*@argument变量包括了所有的参数在里面*/ -moz-box-shadow: @arguments; box-shadow: @arguments;&#125;.container &#123; .box-shadow(2px; 2px);&#125; 编译后的结果为： 12345.container &#123; -webkit-box-shadow: 2px 2px 3px 3px;/*可以看到编译后的结果@argument变量被所有的参数给替换掉了*/ -moz-box-shadow: 2px 2px 3px 3px; box-shadow: 2px 2px 3px 3px;&#125; （4）Less高级参数和@rest变量 Mixin通过使用 … 提供可变数量的参数。 可以通过在变量名称后面放置 … 为变量赋值参数。使用的一些格式如下： 12 代码中使用@rest变量 1234.mixin(@x; @rest...) &#123; // after the variable @a, the @rest is bound to arguments // @arguments is bound to all arguments&#125; Less Mixins函数 （1）Less Mixin范围（作用域描述） 由变量和混合组成的混合可以在调用者的作用域中使用，并且是可见的。 但是有一个例外，如果调用者包含具有相同名称的变量，那么该变量不会复制到调用者的作用域中。 只有调用者范围内的变量被保护，并且继承的变量将被覆盖。 （2）Less Mixin和返回值 mixin类似于函数，在mixin中定义的变量将作为它的返回值，示例如下： 1234567.padding(@x;@y)&#123; @padding:((@x+@y)/2);/*@padding是在mixin中定义的变量，将会作为返回值被返回*/&#125;.container&#123; .padding(80px,120px);/*先调用mixin，相当于对@padding变量赋值了*/ padding-left:@padding;/*这里可以使用@padding变量了，他已经有值了*/&#125; 编译后的结果为： 123.container &#123; padding-left: 100px;&#125; （3）Less mixin定义在另一个mixin中的时候，它也可以用作返回值，示例如下： 123456789.outerMixin(@value) &#123;/*外层mixin*/ .nestedMixin() &#123;/*里面的mixin，这个将会被作为返回值*/ font-size: @value; &#125;&#125;.container&#123; .outerMixin(30); .nestedMixin();/*这里必须要调用才能够取到font-size，前面一步相当于进行的.nestedMixin初始化赋值*/&#125; 编译后的结果如下: 123.container &#123; font-size: 30;&#125; LESS将规则集传递给Mixins 分离的规则集包含一个普通的规则集，如属性，嵌套规则集，变量声明，mixins等。它存储在一个变量中，并包含到其他结构中，其中规则集的所有属性都将被复制到该结构。 范围：（作用域） 分离的规则集中的所有变量和混合宏在被调用或定义的地方都可用，否则调用者和定义范围都可用。 当两个范围包含相同的mixin或variable时，声明范围获取优先级。 分离的规则集体在声明范围中定义。 在将分离的规则集从一个变量复制到另一个变量后，它不会更改其范围。 所有的范围类型如下： （1）定义和调用范围的可见性 变量和mixin在分离的规则集中定义。示例如下： 1234567891011@detached-rulelist:&#123;/*一个变量用于存储分离的规则集（detached分离的）*/ background-color: @caller-variable; .caller-mixin();&#125;.cont &#123; @detached-ruleset(); @caller-variable: #AA86EE; .caller-mixin() &#123; font-style:italic; &#125;&#125; 编译后的结果为： 1234.cont &#123; background-color: #AA86EE; font-style: italic;&#125; （2）LESS 引用将不会修改分离的规则集范围 通过仅给出引用，规则集不访问任何新的范围。（晦涩难懂查看：https://www.w3cschool.cn/less/t_modify_detached_ruleset_scope.html） （3）LESS 解锁将修改分离Ruleset Scope 分离的规则集可以通过导入到范围中来访问。（晦涩难懂查看：https://www.w3cschool.cn/less/unlocking_will_modify_detached_ruleset_scope.html） LESS导入指令 @import 伪指令用于在代码中导入文件。 它将LESS代码分布在不同的文件上，并允许轻松地维护代码的结构。可以将 @import 语句放在代码中的任何位置。 导入指令的导入取决不同的文件扩展名 如果您使用 .css 扩展名，那么它将被视为CSS和 @import 语句保持不变。 如果它包含任何其他扩展名，那么它将被视为LESS并将被导入。 如果没有较少的扩展，那么它将被附加并包含为导入的较少文件。 @import指令支持导入选项，也就是在导入的时候控制导入行为，下面几个就是在import语句中实现的导入伪指令，基本的使用语法为： 1@import(选项) url @import(reference)，用于导入外部文件，但不会将导入的样式添加到编译的CSS文件中。 这是在版本1.5.0 中发布的。 @import(inline)会将CSS复制到输出CSS文件中，而不进行处理。 当CSS文件不是LESS兼容时，这是有用的。 虽然LESS支持大多数标准CSS，但在某些地方不支持注释，并且不修改CSS，它不会支持所有已知的CSS黑客。 即使 @import(inline)不会处理CSS，它将确保所有的CSS将在一个文件中。 这是在版本1.5.0 中发布的。 @import(less)会将文件导入为LESS文件，而不管文件扩展名是什么。 这是在版本1.4.0 中发布的。 @import(css)会将文件导入为常规CSS，而不管文件扩展名。 这是在版本1.4.0 中发布的。 @import(css)会将文件导入为常规CSS，而不管文件扩展名。 这是在版本1.4.0 中发布的。 @import(once)确保文件只导入一次，并且对该文件将忽略任何以下import语句。 这是 @importstatments的默认行为。 这是在版本1.4.0 中发布的。 通过 @import(multiple)，您可以导入具有相同名称的多个文件。 这与一次完全相反。 这是在版本1.4.0 中发布的。 @import (optional)可选允许您在文件不存在时导入文件。 如果要导入的文件不存在并且未使用可选关键字，则LESS会抛出 FileError 错误并停止编译。 这是在版本2.3.0 中发布的。 （防止错误发生导致不再编译） LESS Mixin Guards 想在表达式上匹配简单的值或参数数量，那么你可以使用Guards。 它与mixin声明相关联，并包括附加到mixin的条件。 每个mixin将有一个或多个由逗号分隔的防护，并且guard必须括在括号中。 LESS使用Guards的mixins而不是if / else语句，并执行计算以指定匹配的mixin。 不同类型的mixins guard以及描述 : （1）LESS Guard比较运算符 LESS包含五个保护比较运算符：&lt;，&gt;，&lt;=，&gt; =和=。 您可以使用比较运算符（=）来比较数字，字符串，标识符等，而剩余的运算符只能与数字一起使用。 来个示例说明一下： 1234567891011/*下面定义了三种情况，满足情况会执行相应的mixin*/.mixin (@a) when (@a = 20px)&#123;color:red;&#125;.mixin (@a) when (@a &lt; 20px)&#123;color:blue;&#125;.mixin (@a) &#123; font-size: @a;&#125;.container &#123; .mixin(20px) &#125;/*传入参数20px，那么将会匹配返回20px的mixin*/ 编译后的结果为： 1234.container &#123; color: red; font-size: 20px;&#125; （2）Less Guard逻辑运算符 可以使用关键字来解决Guard逻辑运算符。 您可以使用和关键字组合使用保护条件，并使用not关键字取消条件。 如下： 1234567891011.mixin (@a) when (@a &gt; 50%) and (@a &gt; 5px)&#123; font-size: 14px;&#125;.mixin (@a) when not (@a &lt; 50%) and not (@a &lt; 5px)&#123; font-size: 20px;&#125;.mixin (@a) &#123; color: @a;&#125;.class1 &#123; .mixin(#FF0000) &#125;.class2 &#123; .mixin(#555) &#125; （3）Less提供类型检查函数 less类型检查函数用于对参数类型的检查，检查是否符合条件，有如下的检查函数： iscolor、isnumber、isstring、iskeyword、isurl、ispixel、ispercentage、isem、isunit Less CSS GuardsGuard用于匹配表达式上的简单值或参数个数。 它应用于CSS选择器。 它是用于声明mixin并立即调用它的语法。 要成功地引出 if 类型语句; 将此功能与功能＆结合使用，您可以将多个guards分组。 1234567891011121314@usedScope: global;.mixin() &#123; @usedScope: mixin; .cont when (@usedScope=global) &#123; background-color: red; color: black; &#125; .style when (@usedScope=mixin) &#123; background-color: blue; color: white; &#125; @usedScope: mixin;&#125;.mixin(); Less 循环 Loops语句允许我们多次执行一个语句或一组语句。 当递归mixin与 Guard表达式和模式匹配组合时，可以创建各种迭代/循环结构。 下面是一个简单的例子： 1234567.cont(@count) when(@count&gt;0)&#123;/*将会循环7次*/ .cont((@count - 1));/*这里的@count - 1必须中间要有空格，不然less编译器会把它解释为一个@count-1变量，因此会报找不到变量申明错误，很不科学？？？？？头大*/ width:(25px*@count);&#125;div&#123; .cont(7);&#125; 编译后的结果为： 123div &#123; width: 25px;width: 50px;width: 75px; width: 100px;width: 125px;width: 150px;width: 175px;&#125; Less合并 它是LESS的一个特性，它允许使用单个属性从多个属性中为逗号或空格分隔列表添加值。 它可以用于背景和变换属性。如下所示： （1）less合并逗号：comma（它添加属性值到最后） 1234567.myfunc() &#123; box-shadow+: 5px 5px 5px grey;&#125;.class &#123; .myfunc(); box-shadow+: 0 0 5px #f78181;&#125; 编译后的结果为： 123.class &#123; box-shadow: 5px 5px 5px grey, 0 0 5px #f78181;&#125; （2）less合并空间：space（这是merge的另一个特性，它添加了属性值和空格） 12345678.mixin() &#123; transform+_: scale(1);&#125;.class &#123; .mixin(); transform+_: rotate(2deg);&#125;/*合并使用 + 或 + _ 标志来避开每个连接上意外的连接。 transform 属性修改CSS格式化模型的空间，并可用于旋转，缩放，移动等元素。*/ 编译后的结果为： 123.class &#123; transform: scale(1) rotate(2deg);&#125; 最后的一部分就是LESS函数了 Less提供了很多的函数供使用，大致分为了 字符串函数： （1）escapse（逃逸）：它通过对特殊字符使用URL编码来对字符串或信息进行编码。 您无法编码一些字符，例如，， / ，？ ，@ ，＆amp; ， + ，〜，！ ， $ ，\’和您可以编码的一些字符，例如 \ ，#， &gt; ^ ，(，)， {，} ，: &gt;，＆gt; ，，] ， [和 = 。 （2）e ：它是一个字符串函数，它使用string作为参数，并返回不带引号的信息。它是一个CSS转义，它使用〜“一些内容”转义的值和数字作为参数。 （3）% format ：此函数格式化一个字符串。 它可以写成以下格式: %(string，arguments …) （4）replace：它用于替换字符串中的文本。 它使用一些参数： string :它搜索字符串并替换。 pattern :它搜索正则表达式模式。 replacement :它替换与模式匹配的字符串。 flags :这些是可选的正则表达式标志。 列表函数：Length 、Extract 数学函数：ceil 、floor 、percentage 、round 、sqrt 、abs 、sin 、asin 、cos 、acos 、tan 、atan 、pi 、 pow 、mod 、min 、max 类型函数：isnumber 、isstring 、iscolor 、iskeyword 、isurl 、ispixel 、isem 、ispercentage 、isunit 、isruleset 颜色定义函数：rgb 、rgba 、argb 、hsl 、hsla 、hsv 、hsva 颜色通道函数：hue 、saturation 、lightness 、hsvhue 、hsvsaturation 、hsvvalue 、red 、green 、blue 、alpha 、luma 、luminance 颜色操作：saturate 、desaturate 、lighten 、 darken、 fadein、 fadeout、 fade、 spin 、mix 、 tint 、shade 、greyscale、 contrast 颜色混合函数：multiply 、screen、 overlay、 softlight、 hardlight 、difference、 exclusion 、average、 negation 其它函数：color 、image - size 、 image - width 、image-height 、convert**data - uri 、 default unit [get - unit ](https://www.w3cschool.cn/less/get_unit.html) 、[svg - gradient**](https://www.w3cschool.cn/less/svg_gradient.html)]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化篇]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前端性能优化篇首先附上连接：yahoo的优化原则=》https://developer.yahoo.com/performance/rules.html?guccounter=1 本文摘自《摘自高性能网站建设指南》 前端性能优化策略图（图片源自网络） 时间都去了哪里？浏览器缓存为空 ：当我们首次浏览一个页面的时候，真正的对于html文档的请求占用总请求的时间一小部分。其余大部分时间是用于下载其余的所有组件（图片、脚本、样式表、Flash等等），用户的大部分时间也是用于等待组件的下载。 浏览器缓存不为空 ：如果是第二次浏览该页面，html文档下载时间占比相对来说上升了，因为总的下载时间减少了（由于部分组件得到了缓存的原因，因此不需要再进行下载）。但是大多数时间还是花在了下载组件上面。 为啥需要前端性能优化 第一，如果我们可以将 后端响应时间缩短一半，整体响应时间只能减少5%~10%，如果关注前端性能，同样将响应时间减少一半，整体响应时间可以减少40%~45%。 通过前端通常只需要较少的时间和资源。减少后端延迟需要大改动，而前端不需要。 前端性能调整已经被证明是可行的，Yahoo!中的团队通过最佳实践降低了响应时间，幅度通常为25%或者更高。 性能黄金法则只有10%~20%的最终用户响应时间花在了下载HTML文档商，其余80%~90%时间花在了下载页面的所有组件上。 优化方案方案一：减少HTTP请求（图片地图、CSS Sprites、内联图片和脚本、样式表合并）根据前面的分析大约80%~90%的时间都是花在了组件的下载上面，因此可以减少组件的数量。但是这个又会和产品设计和引发性能问题相互矛盾。（图片地图、CSS Sprites、内联图片和脚本、样式表合并）这些可以解决这个矛盾。 1、图片地图： 解释：图片地图允许你在一个图片上面关联多个URL，目标URL的选择取决于用户点击了图片的那个位置。（当然可以对每一个链接使用单独的一张图片，但是这样会引发多个http请求，因此使用图片地图只会引发一次http请求，响应时间会降低，减少了HTTP的开销）。 实例：一个无图片地图的连接 实例：一个有图片地图的连接 通过比较上述两个页面的加载时间，发现第二个明显时间小于第一个 图片地图包括了服务器端图片地图和客户端图片地图： 服务器端图片地图：将所有的点击提交到同一个URL，向其传递用户点击的x和y坐标，Web服务器将x和y坐标映射为合适的操作。 客户端图片地图（更适用）：将用户的点击映射到一个操作，无需向后端应用程序发送请求，映射通过HTML的MAP标签实现。 图片地图的缺点： 定义图片上面的坐标，如果采用手动方式，很难完成并且容易出错。而且除了矩形之外无法定义其它的形状。 2、CSS Sprites： 和图片地图一样，CSS Sprites也可以合并图片，但是更为灵活。CSS Sprites是将多个图片合并到一个图片中，CSS Sprites适用于任何支持背景图片的HTML标签中。通过使用CSS的background-position属性可以将元素放置到图片中期望的位置上面。 123456789&lt;style&gt; #div1&#123; background-image:url('sxs.gif'); background-position:-260px -90px; width:26px; height:24px; &#125;&lt;/style&gt;&lt;div id="div1"&gt;&lt;/div&gt; 实例：一个CSS Sprites的实例 图片地图要求图中的图片必须是连续的，而CSS Sprites没有这个限制。通过合并图片减少了HTTP的请求，并且比图片地图灵活。此外它还降低了下载量，很多人认为合并后的图片比原来的分开的所有图片总和要大，实际上，合并后的图片比分离的图片的总和要小，因为降低了图片自身的开销（颜色表、格式信息等等） 3、内联图片： 通过使用data:URL模式可以在Web页面包含图片但无需任何额外的HTTP请求。data:URL模式在1995年提议的，对它描述为：允许将小块数据内联为‘立即数’，数据就在URL自身中。其它类似的模式包括：ftp:、file:和mailto:。除此之外还有很多模式，smtp:、pop:、dns:等等。 格式：data:[\&lt;mediatype>][;base64]，\&lt;data> 1&lt;img alt="ddd" src="data:image/gif;base64,R0DHLNCGELNNBXHD476DFS.....DDSGDSDS="/&gt; 实例：一个内联图片的实例 4、合并脚本和样式表 方案二：使用内容发布网络（CDN加速）如果应用程序Web服务器离用户更近，则一个HTTP请求的响应时间将会缩短。另一方面，如果组件Web服务器离用户更近，则多个HTTP请求响应时间将会缩短。 与其重新设计应用程序这一艰巨任务，一遍将应用程序Web服务器分散开，不如先将组件Web服务器分散开，这不仅仅能达到响应时间大幅减少的目的，还很容易实现。 内容发布网络（CDN）： 内容发布网络（CDN）是一组分布在不同地理位置的Web服务器，用于更加有效的向用户发布内容。他还能节约成本。向特定用户发布内容的服务器选择基于对网络的可用度测量，例如CDN可能选择网络阶跃数最小的服务器，或者具有最短响应时间的服务器。 方案三：添加Expires头浏览器（和代理）使用缓存来减少HTTP请求的数量，并减小HTTP响应的大小，使得Web服务器页面加载更快。 Expires头： Web服务器使用Expires头告诉客户端它可以使用一个组件的当前副本，直到指定日期为止。（在这以日期之后，响应应将被认为是无效的） 12#响应头中的信息，这是一个有效期非常长久的Expires头，告诉浏览器有效期持续到2014年4月15日Expries:Mon，15 Apr 2024 20:00:00 GTM Expires的限制： Expires头使用一个特定的时间，他要求服务器和客户端的时钟严格同步，另外，过期日期经常检查，并且一旦这一天到来了，还需要在服务器配置中提供一个新的日期。 HTTP1.1引入了Cache-Control头来客服Expries头的限制。以秒为单位指定更新窗口。如果组件被请求开始过去的秒数少于max-age，浏览器就使用缓存信息。 可以同时指定Expires和Cache-Control:max-age，两个同时出现，规范指定max-age指令将会重写Expires头 123#同时使用Expries:Mon，15 Apr 2024 20:00:00 GTM,Cache-Control:max-age=3150000 长久的Expires头应该包含任何不经常变化的组件，包括图片、脚本、样式表和Flash组件等，HTML文档不应当使用长久的Expires头，因为可能包含动态内容，每次用户请求都会被更新。 方案四：压缩组件（使用gzip编码压缩HTTP响应包）通过减小HTTP响应的大小来减少响应时间，如果HTTP请求响应包很小，传输时间就会减少。 使用gzip编码压缩HTTP响应包是最简单的减小页面大小的技术，但是影响最大。（删除注释、缩短URL等都可以减小响应包，但是收效圣微）。 客户端通过HTTP请求的Accept-Encoding表示对压缩的支持，Web服务器看到这个请求头，就会使用其中的一种方法来压缩响应，通过Content-Encoding头通知客户端。压缩通常能够将相应的数据量减少70%。 1234#请求头Accept-Encoding:gzip,defate#响应头Content-Encoding:gzip Vary响应头 问题描述：如果一个不支持gzip压缩的浏览器发送第一个请求到代理服务器，代理服务器请求下来的东西没有经过压缩而缓存，这个时候，又有一个支持gzip的浏览器发送了一个相同的请求到代理服务器，代理服务器会使用他的缓存内容，就失去了进行压缩的机会。 解决方法：在Web服务器的响应中添加Vary头，Web服务器告诉代理根据一个或者多个请求头来缓存响应。由于压缩取决于Accept-Encoding请求头，因此需要在服务器的Vary响应头中包含Accept-Encoding 1Vary:Accept-Encoding 这样使得代理缓存响应多个版本，为Accept-Encoding请求头的每一个值缓存一份。 使用下面的方式可以禁止代理服务器缓存 123Vary:*#或者Cache-Control:private 因此对于Web服务器的简单配置，压缩尽可能多的组件，就能显著改善页面的反应速度。 方案五：将样式表放在顶部将样式表放于文档底部会导致在浏览器中阻止内容逐步呈现。为了避免当样式变化时重绘页面的元素，浏览器会阻止内容的逐步呈现，也就出现了白屏 。白屏是对无样式内容闪烁的弥补，浏览器可以延迟呈现，知道所有的样式表都下载完成后。 规则五对于加载页面实际时间没有太多的影响，影响的是浏览器对这些组件的顺序的反应。 方案六：将脚本放在底部前面使用样式表的时候，页面逐步呈现会阻止，因此建议将样式表置于HEAD中，使用脚本时，脚本会阻止并行下载，脚本后面的内容，逐步呈现都被阻塞了，后面的组件下载都被阻塞了，将脚本放在页面越靠下的地方，意味着越多的内容能够逐步的呈现。 对页面响应时间影响最大的是，页面组件的数量。HTTP1.1规范建议浏览器从每个主机名并行下载两个组件。因此如果将组件平均放到两个主机中，将会减少一般的时间。 并行下载的优点是很明显的，但是，对于脚本的下载，并行下载实际上是被禁止的，即使用了不同的主机名。 方案七：避免CSS表达式CSS表达式是动态设置CSS属性的一种强大（并且危险）的方式，受到Internet Explorer5和之后的版本支持。 12background-color:expression((new Date()).getHours()%2 ? &quot;#B8D4FF&quot;:&quot;#F08A00&quot;);//上面的代码将会使得背景每小时变化一次 expression方法被其它浏览器忽略。 表达式的问题在于对齐进行求值的频率比人们期望的要高，例如在页面宽度使用表达式求值的时候，它不仅仅在页面呈现和大小改变时求值，当页面滚动、甚至用户鼠标在页面上拖拽的时候也会求值。这样当然会影响效率。 避开这个问题：（使用一次性表达式和事件处理器） 一次性表达式： 如果CSS表达式必须被求值一次，那么可以在在这一次执行中重写它自身，如求背景样式就适用这种用样式 1234567891011&lt;style&gt; p&#123; background-color:expression(altBgcolor(this)); &#125;&lt;/style&gt;&lt;script&gt; function altBgcolor(elem)&#123; elem.style.backgroundColor=(new Date()).getHours()%2 ? "#B8D4FF":"#F08A00"; &#125;&lt;/script&gt;&lt;!--上面代码中，CSS表达式调用了altBgcolor()函数，该函数将样式的background-color属性设置为一个明确的值，并移除了CSS表达式。无论在页面发生大小改变、滚动或者是页面上拖拽鼠标（如果有10个p标签），那么智只会执行10次，比原来少了很多。--&gt; 方案八：使用外部JavaScript和CSS存粹而言，内联（就是把样式表和脚本文件都放在页面中）要快一些。但是将它们外置可以有长期的效益，因为样式表和脚本文件放在外部的话，会有机会缓存的，而html文件特别是那些动态html文件就不会缓存，每次都会请求。 衡量： 页面浏览量：（1）如果每个用户产生的页面浏览量越少，内联的JavaScript和CSS的更快，例如用户每月访问你的网站一次。每次访问之间，外部的javascript和css很可能就被从浏览器缓存中移除了，即使组件可能有长久的Expires头。（2）如果用户能够产生很多的页面，使用外部的javascript和css带来的收益会随着每个用户每月的页面浏览量或者用户每会话的页面浏览量的增加而增加。 组件重用： 如果每个页面都是用了相同的JavaScript和CSS，使用外部组件会提高组件的重用率。 两全其美的办法：（加载后下载、动态内联） 有一些主页，通常每次会只有一个页面浏览量，然而并不是所有的都是这样的，有的会伴随着后续网页的浏览。这个时候，如果作为多次页面浏览量中的第一次的主页，希望主页内联JavaScript和CSS，但又能为所有后续页面浏览量提供外部文件。可以通过在主页加载完成后动态下载外部组件来实现（通过onload事件），这个能够将外部文件放到浏览器缓存中以便用户接下来访问其它页面。动态内联是通过判断是否存在cookie，如果存在，下一次生成页面的时候，就生成使用外部组件的页面。 加载后下载技术： 1234567891011121314151617181920212223&lt;script&gt; window.onload = doOnload; function doOnload()&#123; setTimeout("downLoadComponents()",1000); &#125; function downLoadComponents()&#123; downLoadJs("http://xxxx/xx.js"); downLoadCss("http://xxxx/xx.css"); &#125; function downLoadJs(url)&#123; var elem = document.createElement("script"); elem.src = url; document.body.appendChild(elem); &#125; function downLoadCss(url)&#123; var elem = document.createElement("link"); elem.rel = "stylesheet"; elem.type = "text/css"; elem.href = url; document.body.appendChild(elem); &#125;&lt;/script&gt;&lt;!--首页下载完成后，下载后续的组件--&gt; 方案九：减少DNS查找DNS查找可以被缓存起来以提高性能。这种缓存可以发生在你的ISP或者局域网中一台特殊的缓存服务器上面，这里探索的是发生在独立用户计算机商的DNS缓存。用户请求了一个主机名之后，DNS信息会保留在操作系统的DNS缓存中（Microsoft Windows上面的“DNS Client”服务，使用ipconfig /displaydns可以查看dns，使用ipconfig /flushdns可以刷新dns），之后对该主机请求，无需过多的DNS查找，至少短时间内不需要。 很多浏览器都拥有自己的缓存，缓存中保留了DNS记录，他就不会麻烦操作系统来请求这个记录。只有当浏览器缓存丢弃了记录的时候，他才会向操作系统询问地址。然后操作系统或者通过其缓存来响应这个请求，或者将请求发送给一台远程服务器，这个时候，就会发生潜在的速度降低。 TTL（Time-to-live） 查找返回的DNS记录包含了一个存活时间，Time-to-live值，表示客户端可以对该记录缓存多久。 影响DNS缓存的因素： 服务器可以表明记录被缓存多久，查找返回的DNS包含一个存活时间TTL（time-to-live），尽管操作系统会考虑TTL的值，但是浏览器通常忽略这个值，并设置自己的时间限制。HTTP协议中的Keep-Alive特性可以同时覆盖TTL和浏览器的时间限制。 浏览器对于DNS的缓存数量有限，如果短时间内访问了许多网站，先前的可能丢失，需要再次查找域名，浏览器丢失但是可能操作系统有保留该域名，因此可能无需通过网络发送查询，避免了明显的延迟。 Keep-Alive有重要的作用，默认情况下，一个持久的TCP连接将会一直使用，知道其空闲1分钟为止，由于连接是持久的，无需进行DNS查找。还有一个优点就是，Keep-Alive通过重用现有的连接避免了DNS查找。 减少DNS查找： 减少唯一主机数量：当客户端的DNS缓存为空的时候（浏览器和操作系统都是），DNS查找数量与Web页面中的唯一主机名称数量相等。（减少唯一主机数量，会潜在的减少页面中并行下载的数量）。 方案10：精简JavaScript精简后可以减少文件的大小，通常的方案有： 删除不必要的注释和空格 混淆：可以应用在源代码上的一种方式，会移除注释和空白，同时还会改写代码（将长的命名替换为短的命名）。 通常精简的工具有JSMin和ShrinkSafe等等 方案11：避免重定向重定向用于将用户从一个URL重新路由到另一个URL。常用的有301和302等一系列的。 重定向时浏览器会自动将用户带到由Location字段所给出的URL，重定向所需要的所有信息都在这个里面。301和302在实际中通常不会缓存，除非明确指定Expires和Cache-Control控制行为。 重定向还有其他方式将用户重定向到其它URL，例如使用javaScript代码，document.location或者HTML文档头部包含的meta refresh标签可以在其content属性所指定的秒数后重定向用户等等。 12&lt;meta http-equiv="refresh" content="0;http://www.baidu.com"/&gt;&lt;!--包含上面代码的页面，打开后将会经历0s将用户重定向到百度的首页面--&gt; 问题： 重定向引发的延迟也很严重，因为它延迟了整个HTML文档的传输 避免重定向： 缺少结尾的斜线 ###方案12：删除重复的脚本 方案13：配置ETag减少呈现页面时所必须的HTTP请求数量是加速用户体验的最佳方式，可以通过最大化浏览器缓存组件的能力实现这一个目标。 ETag 实体标签（Entity Tag，ETage）是Web服务器和浏览器用于确认缓存组件有效性的一种机制。 组件是如何被缓存和确认的 浏览器下载组件后，根据需要会将他们存储到缓存中，后面再次请求组件的时候去检查缓存中的组件是否过期。如果缓存过期了，浏览器在重用之前，必须要检查有效性，这称之为条件GET请求，浏览器必须产生这个请求，但是任然比简单的下载组件效率要高，如果组件是有效的（就是它能够和服务器的组件相互匹配），原始服务器不会返回整个组件，而是返回一个”304 Not Modified”状态码。 服务器检查组件是否和服务器相同的两种方式： 比较最新修订日期Last-Modefied 比较实体标签Etag，HTTP1.1引入的 原始服务器通过Last-Modefied响应头哎返回组件的最新修订日期。 1234567#请求头GET /i/yahoo.gif HTTP/1.1HOST:us.yimg.com#响应头HTTP 1.1 200 OKLast-Modefied:tue, 12 Dec 2006 03:03:59 GMTContent-length:1195 下次请求的时候，会带上If-Modefied-Since头将最新修订日期传回原始服务器进行检查、比较。如果匹配，就会返回304响应。 通过实体实体标签进行，使用ETag的唯一约束就是，必须使用引号将值包起来。 12345678#请求头GET /i/yahoo.gif HTTP/1.1HOST:us.yimg.com#响应头HTTP 1.1 200 OKLast-Modefied:tue, 12 Dec 2006 03:03:59 GMTETag:&quot;10c24bc-4ab-457e1c1f&quot;Content-length:1195 下次请求，会使用If-None-Match头将ETag传回原始服务器，如果匹配，就会返回304状态码。 If-None-Match优先级比If-Modefied-Since高 HTTP1.1规范规定的，当同时出现If-None-Match和If-Modefied-Since的时候，则原始服务器禁止返回304(Not Modefied)，除非请求中的条件头字段全部一致。 ETag的问题 ETag的问题是通常使用组件的某些属性来构造它，这些属性对于特定的、寄宿了网站的服务器来说是唯一的，但是当浏览器从一台服务器上获得原始的组件之后，又向另外一个服务器发起条件GET请求时，ETag是不会匹配的（对于采用服务器集群来处理请求的网站来说，这是很常见的一种情况），这种会大大降低有效性验证的成功率。 Apache1.3和2.x使用的ETag格式是inode-size-timestamp，文件系统使用inode来存储注入文件类型、文件所有者、组合访问模式等信息。这些信息从一台服务器到另一个服务器，inode是不同的。后面的去掉了inode信息只保留了size大小和timestamp时间戳或者只有timestamp时间戳。 IIS的ETag格式是Filetimestamp:ChangeNumber，ChangeNumber适用于跟踪IIS配置变化的计数器。 方案14：使用Ajax可缓存改善Ajax请求最重要的方式就是使响应可缓存，前面的规则有一些也适用于Ajax请求。 压缩组件 减少DNS查询 精简JavaScript 避免重定向 Etag 其中对于Ajax请求，规则3是最重要的响应可能会因为数据隐私而不能缓存。当数据被认为是私有的时，大多数都会使用Cache-Control:no-store，使用这个响应头以后，响应不会写入磁盘，但是，对于恶意缓存来说，这一机制，不能确保安全，可能完全忽略掉Cache-Control:no-store头。更安全的方式是使用SSL。 摘自《摘自高性能网站建设指南》]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见浏览器兼容方案]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[常见浏览器兼容方案市场上面的浏览器种类有很多，由于浏览器拥有不同的内核，所以解析网页就存在差异，这些差异就导致了我们写的同样一份代码，在不同的浏览器中表现不同。 常见的浏览器内核：Trident、Gechko、Blink、Webkit 浏览器 内核 IE浏览器 Trident内核，也叫IE内核 Chrome浏览器 Webkit内核，不过现在Chrome是Blink内核了 Firefox浏览器 Gecko内核，也叫FireFox内核 Safari浏览器 Webkit内核 Opera浏览器 最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核； 360浏览器 IE+Chrome双内核 猎豹浏览器 IE+Chrome双内核 百度浏览器 IE内核 QQ浏览器 Trident（兼容模式）+Webkit（高速模式） 不管是对于样式还是其它方面，不同的浏览器有不同的做法（往往是那些特立独行的浏览器IE就是一个例子） （1）使用Normalize.css实现跨浏览器（当然也可以使用css-reset，但是太暴力了） 它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的css reset，Normalize.css是一种现代的，为HTML5准备的优质替代方案。 Normalize.css支持包括手机浏览器在内的超多浏览器，同时对HTML元素，排版，列表，嵌入的内容，表单和表格都进行了一般化。 Normalize.css的优点： 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分HTML元素提供 修复浏览器自身的bug并保证各浏览器的一致性 优化CSS可用性：用一些小技巧 解释代码：用注释和详细的文档来 如果是使用简单粗暴的解决办法就是使用CSS Reset： 1234*&#123; margin: 0; padding: 0; &#125; （2）使用html5shiv.js解决ie9以下浏览器对html5新增标签不识别的问题 这里使用的是ie条件注释（只对ie才有效），下面这段代码表示如果浏览器是IE，并且版本是在IE 9以下，就启用html5shiv.min.js脚本文件。 123&lt;!--[if lt IE 9]--&gt; &lt;script type="text/javascript" src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"&gt;&lt;/script&gt;&lt;!--[endif]--&gt; （3）使用respond.js解决ie9一下浏览器不支持css3 Media Query的问题 123&lt;!--[if lt IE 9]--&gt; &lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;&lt;!--[endif]--&gt; （4）CSS Hack CSS Hack一般都是利用各浏览器的支持CSS的能力和BUG来进行的。 尽量找到通用方法而减少对CSS Hack的使用，大规模使用CSS Hack会带来维护成本的提高以及浏览器版本变化而带来类似Hack失效等系列问题。 条件Hack 条件Hack的语法是使用了IE的条件注释，语法为： 123&lt;!--[if &lt;keywords&gt;? IE &lt;version&gt;?]&gt; HTML代码块&lt;![endif]--&gt; 其中的keyword的取值，if条件共包含六种选择方式：是否、大于、大于或等于、小于、小于或等于、非指定版本。 操作符 含义 lt 小于 gt 大于 lte 小于等于 gte 不小于（大于等于） ! 非指定版本（不等于） 其中的version，是IE的版本。 if条件Hack是HTML级别的（包含但不仅是CSS的Hack，可以选择任何HTML代码块），如下面所示： 1）如果不想在IE中看到某个区域可以使用（换句话说，下面的这个P标签只能够在IE中看到） 123&lt;!--[if IE]&gt; &lt;p&gt;你在非IE中将看不到我的身影&lt;/p&gt;&lt;![endif]--&gt; 这种条件中不仅仅可以是html片段，也可以外部脚本链接(script)、样式表链接(link)以及\&lt;style>标签等等 属性级Hack 语法格式为： 123selector&#123; &lt;hack&gt;?property:value&lt;hack&gt;?;&#125; hack的取值如下： 取值 说明 _ 选择IE6及以下。连接线（中划线）（-）亦可使用，为了避免与某些带中划线的属性混淆，所以使用下划线（_）更为合适。 * 选择IE7及以下。诸如：（+）与（#）之类的均可使用，不过业界对（\）的认知度更高* \9 选择IE6+ \0 选择IE8+和Opera15以下的浏览器 \9\0 只对IE9/IE10生效，是IE9/10的hack 选择不同的浏览器及版本，尽可能减少对CSS Hack的使用。Hack有风险，使用需谨慎。一些CSS Hack由于浏览器存在交叉认识，所以需要通过层层覆盖的方式来实现对不同浏览器进行Hack的。如下面这个例子： 如果想在一段文字在IE6，7，8显示为不同的颜色，可以这样写 12345.test&#123; color:red;/*for IE8+*/ *color:blue;/*for IE7 and earlier*/ _color:yellow;/*for IE6 and earlier*/&#125; 上述Hack均需运行在标准模式下，若在怪异模式下运行，这些Hack将会被不同版本的IE相互识别，导致失效 选择符级Hack 语法格式为： 1&lt;hack&gt; selector&#123;rules&#125; 如下面所示： 1234* html .test &#123; color: #090; &#125; /* For IE6 and earlier */* + html .test &#123; color: #ff0; &#125; /* For IE7 */.test:lang(zh-cmn-Hans) &#123; color: #f00; &#125; /* For IE8+ and not IE */.test:nth-child(1) &#123; color: #0ff; &#125; /* For IE9+ and not IE */ 上述代码中的3,4两行就是典型的利用能力来进行选择的CSS Hack。 （5）浏览器兼容前缀 示例如下： 12345-o-transform:rotate(7deg);/*Opera*/-ms-transform:rotate(7deg);/*IE*/-moz-transform:rotate(7deg);/*FireFox*/-webkit-transform:rotate(7deg);/*Chrome*/transform:rotate(7deg);//同意标识语句 （6）a标签的几种CSS状态顺序 有时候写 a 标签的样式，会疑惑为什么写的样式没有效果，或者点击超链接后，hover、active样式没有效果，其实只是写的样式被覆盖了。 这里可以记住一个顺序（一个小技巧：爱恨）就是：love hate，a标签正确的顺序应该是 link：平常的状态（对应到love中的l） visited：被访问之后（对应到love中的v） hover：鼠标放到链接上面的时候（对应到hate中的h） active：链接被按下的时候（对应到hate中的a） （7）键盘事件keyCode兼容性写法，对于事件红皮书上面有比较详细的介绍，有兼容性写法 1234567891011var inp = document.getElementById('inp')var result = document.getElementById('result')function getKeyCode(e) &#123; e = e ? e : (window.event ? window.event : "") return e.keyCode ? e.keyCode : e.which&#125;inp.onkeypress = function(e) &#123; result.innerHTML = getKeyCode(e)&#125; （8）窗口大小的兼容性写法 12345678910111213//浏览器窗口可视区域大小（不包括工具栏和滚动条等边线）//1600 * 8var client_w = document.documentElement.clientWidth || document.body.clientWidth;var client_h = document.documentElement.clientHeight || document.body.clientHeight//网页内容实际宽高（包括工具栏和滚动条等边线）//1600 * 8var scroll_w = document.documentElement.scrollWidth || document.body.scrollWidth;var scroll_h = document.documentElement.scrollHeight || document.body.scrollHeight;//网页内容实际高（不包括工具栏和滚动条等边线）var offset_w = document.documentElement.offsetWidth || document.body.offsetWidth;var offset_h = document.documentElement.offsetHeight || document.body.offsetHeight;// 滚动的高度var scroll_Top = document.documentElement.scrollTop||document.body.scrollTop; （9）DOM事件的兼容处理 出自红皮书 1234567891011121314151617181920212223242526272829303132333435363738394041var EventUtil = &#123; addHandler:function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handler,false); &#125;else if(element.attachEvent)&#123; element.attachEvent("on"+type,handler); &#125;else&#123; element["on"+type]=handler; &#125; &#125;, removeHandler:function(element,type,handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false); &#125;else if(element.detachEvent)&#123; element.detachEvent("on"+type,handler); &#125;else&#123; element["on"+type] = null;//DOM 0级别删除事件处理程序 &#125; &#125;, getEvent:function(event)&#123; //针对于第一种情况，event是其它浏览器中的，第二种情况是IE的 return event ? event:window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;, preventDefault:function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125; &#125;, stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[响应式Web设计]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%93%8D%E5%BA%94Web%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[本文参考：《响应式Web设计：HTML5+CSS3实战》 响应式Web设计媒体查询简介媒体查询可以让我们根据设备显示器的特性为其设定 CSS样式，仅使用几行代 码，就可以根据诸如视口宽度、屏幕比例、设备方向（横向或纵向）等特性来改变页面 内容的显示方式。 媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询 中可用于检测的媒体特性有 width、height 和 color（等）。使用媒体查询， 可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。 CSS 2样式表通过\&lt;link>标签的 media 属性为样式表指定 设备类型（如显示屏或打印机）(1) \&lt;link rel=”stylesheet” media=”screen and (orientation:position)“ href=”some.css” \/> 上面代码表示：媒体查询表达式询问了媒体类型（你是一块显示屏吗？），然后询问了媒体特性（显 示屏是纵向放置的吗？）任何纵向放置的显示屏设备都会加载some.css样式表。 (2) \&lt;link rel=”stylesheet” media=”not screen and (orientation:position)” href=”some.css” \/> 上面的代码效果与(1)恰恰相反，任何非纵向放置的显示屏设备都会加载some.css (3) \&lt;link rel=”stylesheet” media=”not screen and (orientation:position) and (min-width:800px)“ href=”some.css” \/> 将多个表达式组合在一起，上面又多加了一个限制条件，只有视口宽度大于800像素的显示屏才加载文件。 (4)\&lt;link rel=”stylesheet” media=”not screen and (orientation:position) and (min-width:800px),projection“ href=”some.css” \/> 上面代码写的媒体查询列表，注意第一媒体查询之间使用逗号分割，第二在上面代码中projection之后没有and，也没有任何特性/值的组合，后续表达式，意味着只 要是 projection 就满足条件 媒体查询能检测的特性创建媒体查询的时候，最常用的是设备的视口宽度（width）和屏幕宽度（device-width）,其它的特性检查比较少。 特性 说明 width 视口宽度（常用） height 视口高度 device-width 渲染表面的宽度（对我们来说，就是设备屏幕的宽度）（常用） device-height 渲染表面的高度（对我们来说，就是设备屏幕的高度） orientation 设备处于横向还是竖向 aspect-ratio 基于视口宽度和高度的宽高比，一个 16∶9 比例的显示屏可以这样 定义 aspect-ratio: 16/9 device-aspect-ratio 和 aspect-ratio 类似，基于设备渲染平面宽度和高度的 宽高比 color 每种颜色的位数，例如 min-color: 16 会检测设备是否拥有 16位颜色 color-index 设备的颜色索引表中的颜色数。值必须是非负整数 monochrome 检测单色帧缓冲区中每像素所使用的位数。值必须是非负整数，如 monochrome: 2 resolution 用来检测屏幕或打印机的分辨率，如 min-resolution: 300dpi。还 可以接受每厘米像素点数的度量值，如 min-resolution: 118dpcm scan 电视机的扫描方式，值可设为 progressive（逐行扫描）或 interlace（隔 行扫描）。如 720p HD电视（720p的 p即表明是逐行扫描）匹配 scan: progressive， 而 1080i HD 电视（1080i中的 i表明是隔行扫描）匹配 scan: interlace grid 用来检测输出设备是网格设备还是位图设备 上面表格中的特性，除了最后两个，scan和grid特性，其它的都可以使用min和max前缀创建一个查询范围 阻止移动浏览器自动调整页面的大小iOS和 Android浏览器都基于 WebKit核心，这两种浏览器以及 很多其他浏览器（如 Opera Mobile），都支持用 viewport meta 元素覆盖默认的画布缩放设置。 \&lt;meta name=”viewport” content=”initial-scale=2.0,width=device-width” /> 上面代码中meta标签中可以设置具体的宽度（如像素值）或者缩放比例。上面表示设备实际尺寸的两倍。 meta标签中： name=”viewport” 不言而喻，就是指窗口 content中写属性，用逗号隔开 属性名 属性值 width 设置layout viewport 的宽度，为一个正整数，使用字符串”device-width”表示设备宽度 initial-scale 设置页面的初始缩放值，为一个数字，可以带有小数。 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 user-scalable 是否允许用户缩放可以为no，表示禁止用户缩放 height 设置layout viewport 的高度，很少使用 例如：content=”initial-scale=1.0”，表示浏览器将按照其视口的实际大小来渲染页面。 例如：content=”width=device-width, maximum-scale=3, minimum-scale=0.5”，允许用户将页面多放大至设备 宽度的 3倍，小压缩至设备宽度的一半。 将网页从固定布局转换为百分比布局转换原因媒体查询威力无比，但是也有局限性，那些仅使用媒体查询来 适应不同视口的固定宽度设计，只会从一组 CSS媒体查询规则突变到另一组，两者之间 没有任何平滑渐变，当某个视口处于媒体查询设置的固定 宽度范围之外（可能是某种未知的未来设备及视口），网页就需要水平滚动才能完整浏览。 固定尺寸转换为百分比的公式目标元素宽度 ÷上下文元素宽度 = 百分比宽度 使用此公式重要一点就是一定找对目标元素和上下文元素。例如有如下结构： 123456789101112131415161718&lt;style&gt; #div1&#123; width:960px; &#125; #div2&#123; width:940px; margin-right:10px; margin-left:10px; &#125; #div3&#123; width:40px; &#125;&lt;/style&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt; &lt;div id="div3"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 上面的代码中div2和div3的上下文元素就是div1，那么相应的转换为百分比就是div1:(940 ÷ 960) % ，div2:（40 ÷ 960) % -- 采用em替换px(弹性文字)em相对于px的优势： 一是那 些使用 Internet Explorer 6的用户也将能够缩放文字 二是这样做可以使我们设计师和开 发者的生活更简单 em 的实际大小是相对于其上下文的字体大小而言的，文字也使用公式：目标元素尺寸÷上下文元素尺寸=百分比尺寸。 现代浏览器默认文字大小为16像素，显示申明除外，下面给body应用的任何一种效果都一样： font-size:100% font-size:16px; font-size:1em; 弹性图片、媒体元素实现图片实现流动布局相应的缩放非常简单，只需要在CSS中申明如下： 123img&#123; max-width:100%;&#125; 这样就可以使图片自动缩放到与其容器 100%匹配。更进一步，可以将同样的样式应用到 其他多媒体标签上。 123img,object,video,embed &#123; max-width: 100%; &#125; 给弹性图片设置阈值 图片可以随着视口的伸缩而缩放了。但是如果将视口拉大，直到图片拉伸至超出其原 始尺寸，那问题就麻烦了。通过追加另一个特定样式来为图片设置阈值： max-width 1234.someimageclass &#123; width: 28.9398281%; /* 698 ÷ 202 */ max-width: 202px; &#125; 超级全能的 max-width 属性另一种限制页面无限制扩张的方法是给外层的包裹元素设置一个max-width属性，例如： 1234#wrap&#123; width:96%; max-width:1500px;&#125; 这样意味着页面会缩放至视口宽度的 96%，但绝不会超过 1500像素。]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaScript正则表达式]]></title>
    <url>%2F2018%2F08%2F13%2FjavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[javaScript正则表达式 正则表达式由两种基本字符构成： 原义字符：如a、b、c等等 元字符：\b、\t、\r、\v、、\cX、^、[]等等 此外的* + ? $ ^ . | \ () {} [] 都是javaScript正则表达式中的特殊字符，需要注意。 对象属性 global：是否全文收索，默认为false，可以简写为g ignorecase：是否大小写敏感，默认为false，可以简写为i multiline：多行搜索，默认为false，可以简写为m lastIndex：是当前表达式匹配内容的最后一个字符的下一个位置（也就是当前一轮匹配结束，下一轮的开始位置） source：正则表达式的文本字符串 字符类 一般来说，正则表达式一个字符对应字符串的一个字符，例如：ab\t表示的是ab字符串“ab”+一个tab键的水平制表符。 [] 用来构建一个简单的类 所谓的类就是符合某些特性的对象，一个泛指，而不是特指某个字符 表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类的字符。匹配a或者b或者c ^用来创建反向类/负向类 反向类的意思是不属于某个类的内容 表达式[\^abc]表示匹配不是a或b或c的内容 [a-z]范围类 正则表达式提供了范围类：[a-z]表示从a到z的任意字符，是一个闭区间（包含了a和z） [a-zA-Z]表示a到z或者A-Z 如果要匹配横线-，因为范围类里面本来就有-，会导致不匹配，例如”2016-07-4”.replace(/[0-9]/g,”S”);变为了SSS-SS-S，要匹配中间的横线的话，在正则表达式后面加一个横线：/[0-9-]/g就行了。 js正则提供预定义类来匹配常见的字符类 字符 等价类 含义 . [^\r\n] 除了回车符和换行符之外的所有字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [\t\n\x0B\f\r] 空白符 \S [^\t\n\x0B\f\r] 非空白符 \w [a-zA-Z_0-9] 单词字符（字母、数字、下划线） \W [^a-zA-Z_0-9] 非单词字符 例如/ab\d./就表示匹配ab+一个数字+任意字符的一个字符串，不用预定义类就为/ab[0-9][^\r\t] js正则提供几个常用的边界匹配字符 字符 含义 ^ 以某个字符开始 $ 以某个字符结束 \b 单词边界 \B 非单词边界 例如要匹配“This is a dog”中的This中的is，而不是其它的is，就可以使用正则/\Bis\b/g来匹配 例如匹配一@作为开头的字符串，正则为/^@/gim（这里的g表示全局匹配，i表示忽略大小写，m表示多行匹配，例如字符串中有换行符的时候） 匹配一个@最为结尾的字符串，正则为/@$/gim 量词 正则表达式中，量词表示数量 js正则表达式提供的量词 字符 含义 ? 出现零次或者一次（最多出现一次） + 出现一次或者多次（至少出现一次） * 出现零次或者多次（任意次） {n} 出现n次 {n,m} 出现n到m次 {n,} 至少出现n次 例如/\d{2}/表示出现2次数字，/\d{0,10}/表示数字出现0次到10次 /\d+/表示至少出现一次数字 /\d*/表示出现0此或者多次数字 贪婪模式 对于/\d{3,6}/正则表达是如何匹配？是3次4次还是5次还是6次？ 正则表达式默认是尽可能多的匹配，例如“12345678”.replace(/\d{3,6}/g,”X”) 结果为“X78”正则表达式尽可能多的匹配了 非贪婪模式（就是在量词后面加上一个?） 如果我们想要正则表达式尽可能少的匹配，就是一一旦匹配成功就不再尝试了 在量词后面加上?就可以了 例如：“123456789”.match(/\d{3,5}?/g);结果为[“123”,”456”,”789”]，每次就匹配了最少的次数 “12345678”.replace(/\d{3,6}?/g,”X”);结果为”XX78” 利用()进行分组 使用()可以达到分组的功能，使用量词作用于分组 例如要匹配一个字母一个数字重复3次的场景 ‘a1b2c3d4’.replace(/[a-z]\d{3}/g,”X”);是不对的，因为这里量词是作用于紧挨着它的数字，也就是\d 使用分组才行，也就是：/([a-z]\d){3}/g表示作用与整个分组，这样就达到了想要的效果。 或| 正则表达式使用|表示或，就是走任意一个分支都可以例如yes|no那么走yes或no都可以 上面的例子是作用于yes和no整个单词上面，但是如果只想一部分，例如s或n，这个时候可以使用分组/ye(s|n)o/就可以了。 “ByronsperByrCasper”.replace(/Byr(on|ca)sper/gi,”X”);结果为：XX 使用$反向引用 使用$表示捕获的分组内的内容，对应分组依次为\$1、\$2、\$3来表示 例如：2015-12-25 ===12/25/2015 如果用以前的方法肯定不行，因为时间可能是 变化的，例如2015变为2016，这个时候写死的正则表达式就不可以是使用了，如”2015-12-25”.replace(/\d{4}-\d{2}-\d{2}/g,”12/25/2015”);这是一种死的写法。 比较活用的就是使用分组，并且使用$来访问捕获的分组，上面的代码就成了这个样子： “2015-12-25”.replace(/(d{4})-(\d{2})-(\d{2})/g,”$2/\$3/\$1”) 忽略分组 不希望捕获某些分组，只需要在分组内部加上? : 就可以了，例如：(?:Byron).(ok)分组Byron将会被忽略 前瞻与后顾 正则表达式从文本头部向尾部开始解析，文本尾部方向成为“前” 前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾（后瞻）方向相反 javaScript不支持后顾，符合和不符合特定断言称为肯定（正向）匹配和否定（负向）匹配 名称 正则 含义 正向前瞻 exp(?=assert) 检查符合exp正则以后，还要检查是否符合断言部分 负向前瞻 exp(?!assert) 匹配到正则之后，还要看看他前面的是不是不符合这个断言 正向后顾 exp(?&lt;=assert) javaScript不支持 负向后顾 exp(?&lt;!assert) javaScript不支持 “a23”.replace(/\w(?=\d)/g,”x”);结果为x2\3，匹配的是单词字符后面有数字的 “a234vv”.replace(/\w(?!\d)/g,”x”);结果为ax\3xxx，匹配的是单词字符后面不是数字的 正则对象的方法 test() exec() 字符串中可以使用正则表达式的方法 search()方法，搜索字符串中的字符，不支持全局匹配，并且总是从字符串开始位置开始查找 match()方法 如果非全局调用 也就是没有g标志，那么match()方法就只能在字符串中执行一次匹配，如果没有找到任何匹配文本，将返回null，否则就返回一个数组，其中存放了它找到的匹配文本相关的信息。 返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本，也就是分组。 除了常规的数组元素之外，返回的数组还包含有两个对象属性 index：声明匹配文本的起始字符串在字符串的位置 input：声明对stringObject的引用 如果全局调用 也就是具有标志g，match()方法将执行全局检索，找到字符串的所有匹配子字符串，没有找到返回null，否则返回一个数组 数组元素中存放的是字符串中所有的匹配子串，而且也没有index属性或input属性 split()：第一个参数接收字符串也接受正则表达式 replace()：第一个参数接收字符串也接受正则表达式，他的第二个参数可以为固定的值，也可以为一个function，就是一个回掉，当有一个匹配到了，就会调用这个回掉函数，回掉接收4个参数。 匹配字符串 正则表达式分组内容，没有分组则没有该参数 匹配项在字符串中的index 原字符串 总结自（慕课网）]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaScript中的位运算]]></title>
    <url>%2F2018%2F08%2F13%2FjavaScript%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[javaScript中的位运算]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaScript中的对象继承方式]]></title>
    <url>%2F2018%2F08%2F13%2FjavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[javaScript中的对象的继承方式摘自《JavaScript面向对象编程指南（第二版）》]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaScript中的设计模式]]></title>
    <url>%2F2018%2F08%2F13%2FjavaScript%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[javaScript中的设计模式 设计模式大致上可以分为3种： 创建型模式：涉及到对象的创建与初始化 结构型模式：描述了如何组合对象以提供新的功能 行为型模式：描述对象之间如何通信 单例模式（单件模式） 最简单的单例模式就是使用对象字面量方法： 123456789101112131415161718192021222324var Singleton = &#123; prop1:"something", prop2:"something else", method1:function()&#123; //do something what you can &#125;&#125;//后面的改进，例如想扩展当前单例，可以使用下面这总方式，通过在函数内部封装变量和函数申明，然后向外面暴露接口function Singleton()&#123; var privateProp = "value1"; var publicProp = "value2"; function privateMthod ()&#123; //do something what you want &#125; function publicMethod()&#123; //do somthing what you want &#125; //这里进行接口的暴露，暴露公共方法，暴露公共属性 return &#123; publicMethod:publicMethod, publicProp:publicProp &#125;&#125; 全局变量方式（不推荐） 1234567function SingleObjCreator()&#123; if(typeof globalObj === 'undefined')&#123; globalObj = this; &#125; return globalObj;&#125;//缺点：使用了全局变量，任何时候都可能被覆盖，导致实例丢失，同样的，全局变量任何时候都可能覆盖别的对象。 构造器属性方式（推荐，也有缺陷） 12345678function SingleObjCreator()&#123; if(!SingleObjCreator.single_instance)&#123; SingleObjCreator.single_instance = this; &#125; return SingleObjCreator.single_instance;&#125;//优点：通过构造器属性，解决了全局变量带来的问题//缺点：SingleObjCreator构造器的属性是公有的，任然有被覆盖的风险]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaScript中的函数节流与函数防抖]]></title>
    <url>%2F2018%2F08%2F13%2FjavaScript%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[javaScript中的函数节流与函数防抖 问题：在实际开发中我们很可能用到resize和mousemove等事件，但是这些会频繁的触发，如果是在对应的事件处理函数写一些操作dom的方法的话或者说发送一些ajax请求的话，这样肯定非常耗性能，并且给用户的体验也不好。 函数节流 函数节流的原理：持续触发一个事件，每隔一段的时间，事件只会执行一次。simplely speaking，就像一个水龙头，我们把它关得很小，流水事件一直在触发，但是是每隔一定的事件才滴出一滴水滴。 实现方式： 一般有两种，第一就是使用时间戳，第二就是使用setTimeout定时器。 使用时间戳方式：当我们触发事件的时候，取出当前的时间戳，求出当前时间戳和前一次执行的时间戳的差值，如果差值大于我们设定的时间间隔，那么就执行该动作，并更新执行时间，否则，就不执行该动作。 123456789101112131415161718192021//《JavaScript高级程序设计》//节流函数function throttle(method,context)&#123; //清除上一次的定时器 clearTimeout(method.tId); //重新设置定时器，设定当前周期之后调用 method.tId = setTimeout(function()&#123; //这里是真正要执行的操作 method.call(context); &#125;,100);&#125;//处理函数function handOpe()&#123; /*do something what you want*/&#125;//regist the aciton at the object named windowwindow.onresize = function()&#123; throttle(handOpe,window);&#125; 使用定时器方式：使用定时器的原理就是，当事件触发的时候，检查定时器是否存在，如果存在说明函数还没有执行（因为函数执行中我们清空了timeoutId）所以这个时候我们就不执行，等它执行，并清空定时器，这个时候就可以设置下一个定时器了。 1 compare 第一种（时间戳）事件会立即执行，第二种事件会在wait秒后执行 第一种事件停止后没有办法再执行，第二种事件停止后依然会再执行一次事件函数。 函数防抖 函数防抖 ：如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。 原理：通俗的将就是你尽管触发事件，但是我一定在事件触发n秒后才执行，如果你在一个事件触发的n秒内又触发了这个事件，那我就以新的事件的时间为准，n秒后才执行，总之，就是要等到你触发完事件n秒内不再触发事件。 最简陋的函数防抖方式 12345678910111213141516//例如给添加的onmousemove事件var count = 1;var container = document.getElementById("container");function moveAction()&#123; container.innerHTML = count++;&#125;//注册鼠标移动时间container.onmousemove = debounce(moveAction,1000);//函数防抖，外面包一层函数debounce的原因是里层函数形成闭包，保存外部函数的变量，也就是上一次的timeoutId，以此方便后面清除。function debounce(func,wait)&#123; var timeout; return function()&#123; clearTimeout(timeout); timeout = setTimeout(func,wait); &#125;&#125; 不使用debounce的时候，注册的事件处理程序的this指向的是id为container的dom节点，但是使用了debounce函数以后this值指向了window，是由于由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。 详细可参考MDN setTimeout 这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。 为了保证一致性，对debounce函数改写如下 12345678910function debounce(func,wait)&#123; var timeout; return function()&#123; var context = this; clearTimeout(timeout); setTimeout(function()&#123; func.apply(context); &#125;,wait); &#125;&#125; 但是上面的debounce函数还是有问题，就是事件处理函数一般都会传入事件对象e，通过事件对象获取一些数据，但是在上面代码中指定的func里面获取事件对象为undefined，因为根本就没有传如其它的参数，因此需要传入参数。改写如下 1234567891011function debounce(func,wait)&#123; var timeout; return function()&#123; var context = this; var args = arguments;//接收到参数 clearTimeout(timeout); setTimeout(function()&#123; func.apply(context,args); &#125;,wait); &#125;&#125; 函数节流（throttle）与函数防抖（debounce）应用场景 函数节流（throttle） 频繁的mousemove/keydown，比如高频的鼠标移动，游戏射击类的 搜索联想（keyup） 进度条（我们可能不需要高频的更新进度） 拖拽的dragover等 高频的点击，抽奖等 函数防抖（debounce） scroll/resize事件 文本连续输入，ajax验证/关键字搜索 更多高级的用法，可以参考下面的链接中！ 参考： JavaScript专题之跟着 underscore 学节流 JavaScript专题之跟着underscore学防抖]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaScript异步、消息队列、事件循环]]></title>
    <url>%2F2018%2F08%2F13%2FjavaScript%E5%BC%82%E6%AD%A5%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[javaScript异步、消息队列、事件循环为什么javaScript是单线程？（避免复杂性） JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览器脚本语言JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。 比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征 。 主线程 JS引擎中负责解释和执行JavaScript代码的线程只有一个，就叫做主线程，实际上还有其它的线程，例如处理AJAX请求的线程、处理DOM事件的线程、定时器线程等等给他叫做工作线程。 异步的实现 主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)； 主线程可以继续执行后面的代码，同时工作线程执行异步任务； 工作线程完成工作后，通知主线程； 主线程收到通知后，执行一定的动作(调用回调函数)。 最常用的DOM事件就是异步行为，例如有如下代码： 1234var button = document.getElement('#btn');button.addEventListener('click', function(e) &#123; console.log('按钮');&#125;); 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener函数就是异步过程的发起函数，事件监听函数就是异步过程的回调函数。 事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 任务队列（消息队列）和事件循环 异步过程中，工作线程在异步操作完成以后需要通知主线程，通知机制是通过消息队列和事件循环来实现的。 一句话概括：工作线程将消息放入到消息队列，主线程通过时间循环过程去取消息。 消息队列 ：是一个先进先出队列，里面存放这各种消息。（消息队列里面存放的东西，可以暂时性理解为就是我们注册的回掉函数（回调和异步过程的回调有区别，回调一般是传入到一个函数的函数，比如A(B)，前提是B是一个函数，异步是指将来会运行“一个取自事件队列的函数”的函数），当然具体的结构跟具体的实现有关，这里只是做了一个简单的阐述） 事件循环： 事件循环就是主线程重复的从消息队列中取出消息，执行的过程。取出一个消息并执行的过程就叫做一次循环。 异步操作的图示如下： 从图中可以看出：异步过程的回调函数，一定不会在当前这一轮事件循环中执行。 （这里有点迷糊，如果消息队列中只有当前一个异步回调函数的话呢？） 执行栈 执行栈是一种数据结构 ，记录我们在程序中的位置，如果调用一个函数，则先将当前函数入栈，如果没有涉及到异步操作，那么直接执行完成以后将函数弹出，否则遇到了异步操作，则调用其它的模块执行代码，并且将回调函数放入到消息队列中（任务队列）等待执行。一旦执行栈为空，也就是代码执行完成后，就检查消息队列（这个过程也就是事件循环），看是否有任务执行，将消息队列的队首任务推入到执行栈中执行。 参考文章 https://segmentfault.com/a/1190000010292798 https://segmentfault.com/a/1190000004322358 前端相关技术 javaScript异步、消息队列、事件循环]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaScript数组去重的方法]]></title>
    <url>%2F2018%2F08%2F13%2FjavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[javaScript数组去重的方法参考：http://www.jb51.net/article/74347.htm 遍历数组法 1234567891011function deleteTheRepeat(ary)&#123; //声明一个新数组用于装这些不重复的元素 var newAry = []; //遍历原始数组，通过indexOf判断当前元素中包含在newAry中，如果有，就跳过，否则就push进去。 for(var i = 0; i &lt; ary.length; i ++)&#123; if(newAry.indexOf(ary[i]) == -1)&#123; newAry.push(ary[i]); &#125; &#125; return newAry;&#125; 对象键值对法 12//该方法执行的速度比其他任何方法都快， 就是占用的内存大一些,实现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，不是的话给对象新增该键并放入新数组。注意 点： 判断是否为js对象键时，会自动对传入的键执行“toString()”，不同的键可能会被误认为一样；例如： a[1]、a["1"] 。解决上述问题还是得调用“indexOf”。function 数组下标判断法 12345678910//实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。function deleteTheRepeat(ary)&#123; //结果数组 var newAry = [ary[0]]; for(var i = 1; i &lt; ary.length; i ++)&#123; if(ary.indexOf(ary[i]) == i)&#123; newAry.push(ary[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[零散概念]]></title>
    <url>%2F2018%2F08%2F13%2F%E9%9B%B6%E6%95%A3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[零散概念CSS预处理器 (1)CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。 (2)通俗的说，“CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”，可以在 CSS 中使用变量、简单的逻辑程序、函数（如右侧代码编辑器中就使用了变量$color）等等在编程语言中的一些基本特性，可以让 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。 CSS ReSet HTML标签在浏览器中都有默认的样式，不同的浏览器的默认样式之间存在差别。 例如ul默认带有缩进样式，在IE下，它的缩进是由margin实现的，而在Firefox下却是由padding实现的。 开发时浏览器的默认样式可能会给我们带来多浏览器兼容性问题，影响开发效率。现在很流行的解决方式是一开始就将浏览器的默认样式全部覆盖掉，这就是css reset。 一句话就是：使用CSS ReSet让所有浏览器的CSS样式都用统一的基准 部分CSS ReSet： 123456html &#123;color:#000;background:#FFF;&#125;t5body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td&#123;margin:0;padding:0;&#125;]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小技巧]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[采用Generator函数和for…of循环实现费波拉契数列 1234567891011function* fibonacci()&#123; let [pre,cur] = [0,1]; for(;;)&#123; [pre,cur] = [cur,pre+cur]; yield cur; &#125; &#125; for(let n of fibonacci())&#123; if(n &gt; 1000)&#123;break;&#125;;console.log(n);&#125; 采用yield*命令方便的取出嵌套数组的所有成员 123456789101112131415const tree = ['a',['b','c'],['d','e']];function* iterTree(tree)&#123; //如果是数组 if(Array.isArray(tree))&#123; for(let i = 0; i &lt; tree.length ; i ++)&#123; yield* iterTree(tree[i]); &#125; &#125; else&#123; yield tree; &#125;&#125;for(let x of iterTree(tree))&#123; console.log(x);//依次输出a、b、c、d、e&#125;]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F13%2F%E6%96%AF%E7%89%B9%E6%B2%83%E5%85%8B%E4%BD%9C%E4%B8%9A%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一、说明：本作业是在Windows 10+IDEA开发环境下开发的，采用javaScript语言进行编写 二、作业构思与设计程序需要实现迷宫的生成和连通，并在迷宫构建过程中实时报出异常的操作。采用面向对象的编程思想，将本题目进行抽象，得到如下的类 Command：命令类（封装命令的基本格式） Maze：渲染网格类（封装构建好的迷宫，该类接收一个命令并提供渲染方法） Validator：验证器类（封装各类验证方法） Line：道路连通性连线类（封装连通性的连线） Point：连线端点类，也就是迷宫中的Cell（封装连通性的端点Cell） 在迷宫构建的过程中，想的是每个类各司其职，各做其事（单一职责原则）。程序中输入的合法性检查使用Validator类进行检查，而每个部分的检查都在自己的部分，比如，校验Command的输入格式是否合法，这个过程是在Command中进行。 三、运行和测试1、运行： 在IDEA中打开程序文件（或者直接找一个支持运行js代码的IDE也行），右键菜单选择“Run maze.js”选项便可以看到结果。 2、测试： 程序输入包括两行 ​第一行是迷宫 道路网格 的尺寸。例如 3 x 3 的迷宫为 3 3，而 5 x 4 的迷宫为 5 4（5 行 4 列）。 ​第二行是迷宫 道路网格 的连通性定义。如果 cell(0,1) 和 cell(0,2) 是连通的，则表示为： 0,1 0,2，多个连通以分号 ; 隔开。 （1）用例一：合法用例（3行3列） 输入： 123 30,1 0,2;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1 输出： 1234567[M] [M] [M] [M] [M] [M] [M] [M] [R] [M] [R] [R] [R] [M] [M] [R] [M] [R] [M] [R] [M] [M] [R] [R] [R] [R] [R] [M] [M] [M] [M] [R] [M] [R] [M] [M] [R] [R] [R] [M] [R] [M] [M] [M] [M] [M] [M] [M] [M] （2）用例二：合法用例（4行5列） 输入： 124 50,1 0,2;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1 输出： 1234567891011[M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [R] [M] [R] [R] [R] [M] [R] [M] [R] [M] [M] [R] [M] [R] [M] [R] [M] [M] [M] [M] [M] [M] [R] [R] [R] [R] [R] [M] [R] [M] [R] [M] [M] [M] [M] [R] [M] [R] [M] [M] [M] [M] [M] [M] [R] [R] [R] [M] [R] [M] [R] [M] [R] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [R] [M] [R] [M] [R] [M] [R] [M] [R] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [R] [M] [R] [M] [R] [M] [R] [M] [R] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] [M] （3）用例三：输入命令的格式不符合约定 输入： 123453+30,1 0,2;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1或者3 30：1 02;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1 输出： 1Incorrect command format. （4）用例四：输入数字超出允许范围之外 输入： 12345-3 30,1 0,2;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1或者：3 30,-1 0,2;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1 输出： 1Number out of range. （5）用例五：输入无效数字（拥有无效符号或者不是数字） 输入： 123456783 3@0,1 0,2;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1或者3 30,1@ 0,2$;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1或者x 30,1 0,2;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1 输出： 1Invalid number format. （6）用例六：连通性错误 输入： 123 30,1 0,1;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1 输出 1Maze format error.]]></content>
  </entry>
  <entry>
    <title><![CDATA[浮动的清除和BFC]]></title>
    <url>%2F2018%2F08%2F13%2F%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B8%85%E9%99%A4BFC%2F</url>
    <content type="text"><![CDATA[浮动的清除和BFC元素设置浮动，可以左右移动，直到遇到另一个浮动框或者遇到它外边缘的包含框（父元素）。浮动框不属于文档流中的普通流，元素浮动之后，不会影响块元素的布局，只会影响内联元素布局。当包含块的高度小于浮动框的时候，就会出现“高度塌陷”现象了。通常我们使用清除浮动的方进行，清除浮动有两种方法，第一个是使用clear属性，第二个就是使用BFC清除浮动进行清除浮动。 clear是如何清除浮动的？ clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。需要注意的是我们是在别的元素上清除浮动来实现撑开高度的，而不是在浮动元素上面。(部分参考https://www.jianshu.com/p/09bd5873bed4) （1）通过在浮动元素后面加入clear属性为both的属性 下面的这个布局就会引起包含元素高度塌陷，浮动元素脱离了文档流，并不占据文档流的位置，自然父元素也就不能被撑开，所以没了高度。 1234567891011121314151617&lt;style&gt;.box-wrapper &#123; border: 5px solid red;&#125;.box-wrapper .box &#123; float: left; width: 100px; height: 100px; margin: 20px; background-color: green;&#125;&lt;/style&gt;&lt;div class="box-wrapper"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/div&gt; 通过使用clear:both进行清除浮动 123456&lt;div class="box-wrapper"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div style="clear:both"&gt;&lt;/div&gt;&lt;/div&gt; （2）通过:after伪类选择器进行清除浮动（最优方案）,这是使用clear清除浮动的最佳实践 12345678910111213141516171819202122/*现代浏览器清除方案，不支持IE6/7*/.container:after&#123; display:block; content:''; clear:both; height:0;&#125;/*通过引入zoom支持IE6/7，是CSS Hack方式*/.container&#123; *zoom:1;&#125;/*下面是全浏览器解决方案，引入了zoom以支持IE6/7，同时加入:before以解决现代浏览器上边距折叠的问题*/.container:before,.container:after&#123; display:table;/*这里为block也可以*/ content:" "; clear:both;&#125;.container&#123; *zoom:1;&#125; 通过BFC清除浮动（BFC） BFC（Block Format Context ：块级格式化上下文），它是按照块级盒子布局的。我们了解他的特征、触发方式、常见使用场景这些就够了。 满足下面条件之一的都会生成BFC 根元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption position的值为absolute或者fixed BFC的特征 可以将BFC看作是一个页面中的迷你布局，一旦创创建了一个BFC它其中的所有元素都会被它包裹。 正如我们所见的，当盒子变成BFC之后，它内部的浮动元素就再也不可能突破它的底部（也就是说，盒子不再会因内部元素浮动而坍塌）。BFC,除了这个以外，还有另外一个功能，BFC可以阻止外边距的叠加，一个BFC会停止去围绕浮动元素。如果一个元素创建了BFC，它就不会去围绕（或者说包裹）任何浮动元素。所以BFC的特点如下： BFC容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的BFC来解决垂直边距折叠问题。 BFC的一个特性是可以包含浮动；通常用来解决浮动父元素高度坍塌的问题。 其中，BFC清除浮动就是用的“包含浮动”这条特性。 那么，怎样才能触发BFC呢？ 我们可以给父元素添加以下属性来触发BFC： float 为 left | right overflow为hidden|auto|scroll display为table-cell|table-caption|inline-block|flex|inline-flex position为absolute|fixed 所以我们可以给父元素设置overflow:auto来简单的实现BFC清除浮动，但是为了兼容IE最好用overflow:hidden。但是这样元素阴影或下拉菜单会被截断，比较局限。 123.box-wrapper&#123; overflow: hidden;&#125;]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js跨域请求方式原理以及使用]]></title>
    <url>%2F2018%2F08%2F13%2F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[js跨域请求方式原理以及使用 在CORS出现以前，要实现跨域Ajax通信需要费一些周折，通常开发人员利用DOM中能够执行跨域请求的功能，不依赖XHR对象同样能够发送某种请求。 JSONP JSONP是JSON with padding（填充式json或者参数式json）的简写。 JSONP的组成：JSONP = 回掉函数+数据。回掉函数是当响应到来时应该在页面调用的函数，回掉函数名字一般在请求中指定。数据就是传入回掉函数的json数据。 原理：JSONP是通过动态\&lt;script\元素来使用的，利用\&lt;script\元素不受限制的从其它领域加载资源的原理。此外除了\&lt;script\标签，还有\&lt;img\标签 使用 ： 1234567891011function getTheJONPData()&#123; var script = document.createElement("script"); //设置src属性后还不会去加载 script.src = "https://api.douban.com/v2/book/search?q=html&amp;count=1&amp;callback=handleResponse";//这里指定回掉函数 //插入到DOM后，开始加载 document.body.insertBefore(script,document.body.firstChild);&#125;/*JSONP的回掉函数*/function handleResponse(response)&#123; console.log(response);&#125; 优点与不足：优点是简单易用，且能够直接访问响应文本，支持在浏览器服务器双向通信。不足是第一JSONP是从其它域中加载代码执行，很可能在响应中带了一些恶意代码，第二是确定JSONP的请求是否失败并不容易。（后面HTML5为\&lt;script\添加了onerror事件） 图像Ping 原理 ：一个网页可以从任何的网页中加载图像，不用担心跨域问题，因此可以使用动态创建图像，使用他们的onload和onerror时间处理程序来确定是否接收到了响应。 动态创建的图像常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求数据通过查询字符串形式发送的，响应可以实任意内容，但通常是像素图或者204响应（no content），通过图像Ping，浏览器得不到任何具体的数据 ，通过监听load和error事件能够知道响应是什么时候收到的。 使用 ： 12345var img = new Image();img.onload = img.onerror = function()&#123;//不能访问服务器的响应文本 alert("加载完成");&#125;img.src = "https://api.douban.com/v2/book/search?q=html&amp;count=1"; 优点与不足：图像Ping的缺点是只能够发送GET请求和无法访问服务器的响应文本，只能用于与服务器之间的简单通信。 CORS CORS是一种跨域访问机制，可以让Ajax实现跨域访问。 CORS思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求是否成功还是失败。 IE对CORS的实现 ：IE有对CORS的实现是XDR（XDomainRequest）类型，这个与XHR类似，但是能够实现安全的跨域访问。他的特点如下： cookie不会随着请求发送，也不会随响应返回 只能够设置请求头部信息中的Content-type字段 不能访问响应头部信息 只支持GET和POST请求 上面的变化，使得CSRF（Cross-Site Request Forgery）跨站请求伪造和XSS（Cross-Site Scripting）跨站脚本攻击得到了缓解。XDR的使用和XHR十分相似，XDR在接收到响应之后只能够访问原始文本，无法访问状态码，而且只要有响应就会触发load事件，如果失败（包括响应中缺少：Access-Control-Allow-Origin头部）就会触发error事件。 123456var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;xdr.open("get","https://api.douban.com/v2/book/search?q=html&amp;count=1");xdr.send(null); 其它浏览器对CORS的实现 ：它们通过XMLHttpRequest对象实现对CORS的原生支持，在尝试打开不同来源的资源时，无需额外的代码就可以触发这个行为，要请求位于另一个域中的资源使用标准的XHR对象然后在open方法中传入绝对URL即可。他的特点如下： 不能使用setRequestHeader()设置自定义头部 不能发送和接收cookie 调用getAllResponseHeaders()总是返回空字符串 透明服务器验证机制：CORS支持开发人员使用自定义头部、GET或者POST之外的方法，以及不同的类型的主体，使用下面高级选项发送请求的时候，浏览会使用OPTIONS方法向服务器发送一个Preflight请求。 Origin：源地址（与简单的请求相同） Access-Control-Request-Method：请求自身使用的方法 Access-Control-Request-Headers：（可选）自定义头部，多个使用逗号隔开。 发送请求后，服务器可以决定是否允许这种请求，服务器通过设置响应头来与浏览器进行沟通 Access-Control-Allow-Origin：与简单的请求相同，允许跨域的域名或IP Access-Control-Allow-Methods：允许使用的方法，多个使用逗号隔开 Access-Control-Allow-Headers：允许的头部，多个使用逗号隔开 Access-Control-Max-age：应该将这个preflight请求缓存多长时间（秒表示） 带凭据的请求：默认情况下面，跨域请求不带凭据（cookie、http认证客户端SSL证明等），通过设置withCredentials属性为true，可以指定某个请求带上凭据，服务器如果支持带凭据的请求，应该设置HTTP响应头来响应。 Access-Control-Allow-Credentials:true 使用 ： 12345678910111213//服务器需要设置下面的响应头中的一种或者多种Access-Control-Allow-Origin: *Access-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400//如果跨域时需要带上凭证，需要对请求和响应设置属性，//响应头设置允许带凭证的请求&quot;Access-Control-Allow-Credentials&quot;: true//响应头设置Access-Control-Allow-Origin为具体的ip或者域名，不能为*&quot;Access-Control-Allow-Origin&quot;:&quot;127.0.0.1&quot;//请求Ajax设置withCredentials属性&quot;withCredentials&quot;:true 除了上面的几种以外还有其它的方式，例如：window.name+iframe方式、window.postMessage()方式、修改document.domain跨子域、WebSocket、代理。]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax笔记]]></title>
    <url>%2F2018%2F08%2F13%2FAjax%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Ajax Ajax技术的核心是XMLHttpRequest对象。XMLHttpRequext实际上就是在浏览器和服务器之间加入了中间层，这个中间层起到了代理作用，并负责通信。 Ajax的技术组成 XMLHttpRequest对象的方法 方法 描述 open(string method,string url,boolean asynch,string name,string pwd) 建立HTTP请求，method参数用于指定HTTP请求方法，url指定资源地址，asynch 参数表示采用异步方式发送，默认为true，也就是默认是异步,false表示同步，name和pwd可选，指定用户名和密码 abort() 停止当前请求 getAllResponseHeaders() 返回HTTP响应的头部信息 getResponseHeader(string header) 返回指定的一个响应的头部信息，例如getResponseHeader(“Content-Type”)会返回响应类型的值 send(varian content) 向服务器发送请求，参数指定随着HTTP请求发送的数据，参数类型可以为字符串类型和文档对象 setRequestHeader(string header, string value) 设置HTTP请求的头部信息，要成功发送请求，必须在在调用open()方法之后且在调用send()方法之前调用setRequestHeader() overrideMimeType(String mime) XMLHttpRequest2级的方法，用于重写服务器返回的MIME类型。因为XHR会根据服务器返回的MIME类型具体的处理响应。overrideMimeType方法必须在send方法之前 XMLHttpRequest对象的属性 属性 描述 readyState （prop）请求处理状态描述，有五个阶段（1）0：（未初始化）未初始化，XMLHttpRequest对象已经创建，但是没有初始化请求（2）1：（启动）正在加载请求的URL，在调用open()方法后与调用send()方法之间就进入改状态，这个时候没有发生网络通信（3）2：（发送）加载完成，调用send()方法后就进入了改状态（4）3：（接收）在交互中，收到了部分响应数据，但是responseText和responseXML处于不可用状态（5）4：（完成）完成，已经从服务器端收到了完整的响应数据。 responseText （prop）服务器响应的数据部分，数据类型为字符串 responseXML 服务器响应的数据部分，数据类型为一个XML文档对象（DOM） status （prop）服务器响应状态，得到的标准HTTP协议的响应状态码，如404，200，500等等（在超时终止之后再访问status属性，将会报错，可以将status检查语句放在try-catch中） statusText （prop）状态码的说明，与status相对应，如status=404，那么statusText=Not Found onreadystatechange （function）当readyState属性发生变化的时候，XMLHttpRequest对象自动调用由onreadystatechange所指定的JavaScript timeout （prop）开始是IE添加的属性，后来被纳入XMLHttpRequest2级规范中来。用来进行超时设定 ontimeout （function）对应于timeout的回掉函数，如果规定时间没有接收到响应，将会调用这个函数 onloadstart （function）对应于loadstart事件的回掉函数，在接收到响应数据的第一个字节的时候触发的回掉函数 onprogress （function）对应于progress事件的回掉函数，在接收到响应期间持续不断的触发的回掉函数 onabort （function）对应于abort事件的回掉函数，在调用abort()方法而终止连接时触发的回掉函数 onload （function）对应于load事件的回掉函数，在接收到完整的响应数据时触发的回掉函数 onloadend （function）对应于loadend事件的回掉函数，在通信完成或者触发error、abort或load事件后触发的回掉函数 创建XMLHttpRequest对象 12345678910111213141516171819202122function createXHR()&#123; if(window.XMLHttpRequest)&#123; return new XMLHttpRequest(); &#125; //IE中会遇到3种不同版本的XHR对象var i , len; else if(window.ActiveXObject)&#123; var versions = ["MSXML2.XMLHttp.6.0","MSXML2.XMLHttp.2.0","MSXML2.XMLHttp"]; var i , len; for(i = 0,len = version.length; i &lt; len; i ++)&#123; try&#123; new ActiveXObjct(versions[i]); autuments.callee.activeXString = versions[i]; break; &#125;catch(ex)&#123; //跳过 &#125; &#125; &#125; else&#123; throw new Error("No XHR object available."); &#125;&#125; 发送XHR请求，并监听响应 123456789101112131415//HTTP中状态码304表示访问的资源没有经过修改，可以使用缓存中的数据var xhr = createXHR();//创建XHR对象，这个时候xhr.readyState=0，是未初始化状态xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123;//当xhr.readyState=4的时候，表示已经收到了全部的响应数据，可以在客户端使用了 if(xhr.status = 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304)&#123; var responseText = xhr.responseText;//这里可以操作数据了 &#125; else&#123; //出错了 &#125; &#125;&#125;xhr.open(method,url,true);//初始化一个请求，这个时候xhr.readyState=1xhr.send(null);//发送一个请求，这个时候xhr.readyState=2//xhr.readyState=3的时候表示已经收到了部分数据 GET和POST请求方式不同之处 比较内容 GET方式 POST方式 数据传输载体 URL HTTP头键值对 数据长度 通常1024字节 无限制 安全性 URL明文传输，不安全 可加密后在HTTP头中传输，较为安全 请求提交方式 可以为form，也可以为任意的URL连接 只能以form方式提交 一般用途 获取信息 提交信息（也可以获取信息）]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>XHR</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5的点滴]]></title>
    <url>%2F2018%2F08%2F13%2FHTML5%E7%9A%84%E7%82%B9%E6%BB%B4%2F</url>
    <content type="text"><![CDATA[HTML5的点滴HTML5 强调简化标签，仅链接那些我们必须 的 CSS、JavaScript和图片文件 标准的 HTML 4.01网页的文档类型声明如下：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/ TR/html4/loose.dtd” &gt; HTML5简化以后：&lt;!DOCTYPE html HTML5也接受非常松散的语法 \&lt;script src=”js/jquery-1.6.2.js”>\&lt;/script> HTML5中type属性不再需要。 \&lt;sCRipt SrC=js/jquery-1.6.2.js>\&lt;/script> HTML5中大小写混用，源文件引用没有加入””，同样通过验证。 \&lt;link href=CSS/main.css rel=stylesheet> 没有闭合标签斜杠（/），属性值没有引号括起来，没有type声明，HTML5都接受。 宽松的语法可应用于整个文档，\ HTML5增加了语义化标签 HTML5结构级语义元素： 这对我们来说是件好事，但更重要的是对 搜索引擎来也是件好事。搜素引擎能比以前更好地理解我们的网页，并相应地评定网页 内容。如：使用\&lt;nav\标签会使我们的代码变得更有语义，这就是导航栏。 \&lt;section>：元素用来定义文档或应用程序中的区域（或节）。例如，可以用它组织你的个 人信息，一个\&lt;section>用于联系信息，另一个用于新闻动态。 \&lt;nav>：用来定义文档的主导航区域，其中的链接指向其他页面或当前页面的某些区域。 \&lt;article>：与\&lt;section>元素用容易混淆，\&lt;article>元素用来包裹独立的内容片段。当搭建一个页面时，想想你准备放入\&lt;article>标签的内容能否作为一个整块而被复制粘贴到另外一个完全不同的网站且能保持完整的意义？应该使用\&lt;article>标签包裹的内容，明显的例子 就是博客正文。如果出现嵌套的\&lt;article>元素，那内层的\&lt;article>元素内容 应该和外层文章内容直接有关。 \&lt;aside>：元素用来表示与页面主内容松散相关的内容。在实践中，我经常将其用作侧边栏（当它包含合适的内容时）。另外，引文、广告以及导航元素（如友情链接等）也可以使用它。 \&lt;hgroup> ：如果页面中有一组使用\&lt;h1>、\&lt;h2>、\&lt;h3>等标签的标题、标语和副标题，则可以考虑 使用\&lt;hgroup>将它们包裹起来。这样在 HTML5的大纲结构算法中就会隐藏次级标题元 素，从而只让\&lt;hgroup>中的第一个标题元素进入文档大纲。 \&lt;header> ：元素不计入大纲结构，所以不能用它来划分内容结构，而是应该用它来包含对区域内容的介绍说明。实际使用中，\&lt;header>可用作网站头部的“刊头”区域，也 可用作对其他内容如\&lt;article\元素的简要介绍。 \&lt;footer> ：\&lt;footer>元素也不计入大纲结构，所以也不能用于划分内容结构。 应该用它来包含其所在区域的辅助信息。例如可以用它包含一组指向其他页面的超链接， 或者用它包含版权信息。它也可以视情况在同一个页面上多次出现。 例如博客网站的页脚可以用它，同时博客正文&lt;article>元素内的文脚也可以用它。不 过规范指出，博文作者的联系信息应该使用\&lt;address>元素来包裹。 \&lt;address> ：元素用于明确地标注离其近的\&lt;article>或\&lt;body>祖先元素的联系信息。 为避免产生混淆，请记住\&lt;address>中一般不放具体的邮政地址，除非相应内容确实需 要联系地址。而邮政地址和其他可能会改变的联系信息应该使用\&lt;p>标签来包裹。 当页面中有\&lt;article>或\&lt;section>元素时，每个\&lt;article>或\&lt;section>元素都可以有自己的头部、脚 注和导航。需要谨记的是，使用\&lt;section>的目的不是为了美化样式，而是为了标识一个鲜明独立 的内容块。一个内容块（section）一般都应该带有标题 HTML5的文本级语义元素：HTML5 还修订了一些被称之为行内元素的标签。 \&lt;b> ：它的实际用途其实是“给文本加粗”，HTML5标准定义为，一小段文本，纯粹为了吸引人的注意，除此之外不传达任何重要性，也不 暗示其他语态或语气。如文档摘要中的关键词等等。（加粗） \&lt;em> ：HTML5中它的语义是，强调内容中的重点。（斜体） \&lt;i> ：HTML5标准中对&lt;i的描述，一小段有不同语态或语气的文字，或者是样子上与普通文章有所差异以便 标明不同特点的文字。 （斜体） HTML中的其它标签： \&lt;video>：添加多媒体 \&lt;audio>：添加音频 HTML5中可以在\&lt;a\标签中嵌入多个元素 12345&lt;a&gt; &lt;h2&gt;The Home Page&lt;/h2&gt; &lt;p&gt;This is paragraph also links to the home page&lt;/p&gt; &lt;img src="som/isx.jpg" alt="home-slice"/&gt;&lt;/a&gt; 唯一需要记住的是——很明显：不能在一个标签中嵌套另一个标签，也不能在标签中嵌 套表单 HTML废弃的东西（包括暂保留和非保留的） script链接中的 language属性 img标签中的 border属性（暂保留） strike、enter、font、acronym、frame 和 frameset……（非保留标签） 用HTML5的方法为页面添加视屏或者音频 HTML4.01在网页中添加媒体非常麻烦，HTML5就非常简单： \&lt;video src=”myVideo.ogg”>\&lt;/video> 123456&lt;video src="video/myVideo.mp4" width="640" height="480"&gt; What, do you mean you don't understand HTML5?&lt;/video&gt; &lt;!--上面代码在网页中会出现视屏控件，视屏会出现，但是没有播放控制栏，最佳controls属性就会出现视屏控制栏，再追加autoplay属性，就会出现自动播放，一般不使用，因为我们一般不喜欢自动播放--&gt;&lt;video src="video/myVideo.mp4" width="640" height="640" controls autoplay&lt;/video&gt; 属性： controls：显示播放控制栏 autoplay：控制自动播放 preload：用来控制媒体预加载 loop：用来重复播放视屏 poster：定义视屏缩略图，这个属性在视频播放延时非常有用 要使用某一个属性，在video标签中追加上面属性中的某一个即可。下面包括上面所有属性： 123&lt;video src="video/myVideo.mp4" width="640" height="480" controls autoplay preload="auto" loop poster="myVideoPoster.jpg" What, do you mean you don't understand HTML5?&lt;/video&gt; \&lt;source>：标签提供备用的媒体源文件 由于目前的情况是， 一些浏览器支持某一套视频和音频文件格式，而另一些浏览器则支持其他格式。有一种方法能在一个标签内支持多种媒体格式。那就是\&lt;source\标签。 手握多种格式的媒体文件，则可以这样编写视频标签： 123456&lt;video width="640" height="480" controls autoplay preload="auto" loop poster="myVideoPoster.jpg"&gt; &lt;source src="video/myVideo.ogv" type="video/ogg"&gt; &lt;source src="video/myVideo.mp4" type="video/mp4"&gt; What, do you mean you don't understand HTML5? &lt;/video&gt; &lt;!--上面代码根据浏览器的支持格式解析，如果浏览器支持ogg格式的，那么会使用第一个，否则会继续解析下一个&lt;source标签--&gt; \&lt;audio>的使用和\&lt;video>除了width，height，poster属性之外，其它的使用基本相同，甚至可以互换使用，最大的差别就是\&lt;audio>没有可视的内容播放区域。 响应式视屏，如果设置了\&lt;video>标签的height，width属性，那么就不能响应式，解决办法就是删除height，weight添加代码 video{max-width:100%;height:auto} 这种方法对本页面中的视频文件很有用，但它不能解决使用 iframe 嵌入的视频的响应 问题。要解决这样的问题，可以使用插件。 离线的Web应用 我们知道肯定会有越来越多的移动设备用户访问我们的 网站，为他们提供一种不需要网络连接仍可访问网站内容的途径如何？HTML5 的离线 Web 应用特性将其变成了可能。 例子：假设有一个在线笔记应用，当用户的手机网络断开时，他可能正在编辑一则笔记。使用 HTML5的离线 Web 应用，他就可以继续离线编辑笔记，然后等到网络再次连接时将本地 数据发送到服务器。 使用HTML5离线Web应用为我们的网站创建一个离线版本 机制： 离线Web应用的运行机制是每个需要离线使用的网页都指定一个后缀名为.manifest的 文本文件。这个文本文件罗列了该网页离线使用时所需的所有资源文件（HTML、图片 JavaScript等等）。支持离线 Web 应用的浏览器会自动读取.manifest 文件，下载文件中 所罗列的资源文件，并将其缓存在本地以备网络断开时使用。 让网页可以离线使用 在html文件中，指定一个.manifest文件： 1234567891011121314&lt;html lang='en' manifest="/my.manifest"&gt;&lt;/html&gt;&lt;!--文件名可以随意，但是后缀名建议使用.manifest--&lt;!--必须在每一个准备离线使用的页面的HTML标签中都追加manifest--&lt;!--如果使用的是 Apache服务器，可能还需要修改一下.htaccess文件，在里面追加一条代码AddType text/cache-manifest .manifest这样就保证了.manifest 文件拥有正确的 MIME类型，即 text/cache-manifest。 --&gt;&lt;!--.htaccess 文件中还可以加入以下代码 &lt;Files my.manifest ExpiresActive On ExpiresDefault "access"&gt; &lt;/Files&gt; 上面这几行代码，可以阻止浏览器缓存缓存文件。因为my.manifest是一个静态文件，浏览器默认会缓存这个文件，加入上面的几行代码，可以告诉浏览器不要这么干--&gt; 填充my.manifest文件，告诉浏览器哪些文件是用作离线存储的 123456789101112CACHE MANIFEST#v1CACHE:view/index.htmlcss/index.cssimg/head.jpgNETWORK:*FALLBACK://offline.html manifest文件必须以CACHE MANIFEST开头，第二行就是一句注释，注明了 manifest文 件的版本号。 CACHE:部分罗列了所有离线使用所需的文件。这些文件的路径都是相对 offline.manifest 而言的，所以文件路径可能需要根据情况稍作修改。使用绝对路径也是可以的。 NETWORK:部分罗列了所有不需要被缓存的文件。此处罗列的文件在网络畅通的情况下都会直接跳过缓存。如果你想网站内容在网络畅通 的情况下及时更新（而不是仅在离线缓存中查找），可以在此处使用*。星号被称为在线 白名单通配符。 FALLBACK:部分使用/字符定义了一个 URL模板。它的作用是访问每个页面时都会问“缓存 中有这个页面吗？”，如果有则显示缓存页面，如果没有则显示指定的 offline.html 文件。 有一种更简单的办法来设置 offline.manifest 文件，任何指定了离 线 manifest 文件的页面（就是在标签中追加了 manifest=”/offline.manifest”的页 面）在被用户访问时都会被自动加入到本地缓存。选择使用这个方法时有一点需要注意，这种方法只会下载和缓存用户访问的 HTML页面， 不会缓存页面内引入的图片、JavaScript或者其他资源文件。如果这些资源文件是必需的， 那么请按照上节中的方法在 CACHE:部分专门声明这类文件。 123456CACHE MANIFEST # Cache Manifest v1 FALLBACK: //offline.html NETWORK: * 版本注释的用途 对网站内容或任何资源文件做了修改之后，你必须得对 offline.manifest 文件也做点 修改并将其重新上传服务器。这样就能让服务器为浏览器提供新版本文件，而浏览器则 会下载该新版本文件并再次触发离线存储进程。# Cache Manifest v1]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RequireJs和AMD规范模块化编程相关笔记]]></title>
    <url>%2F2018%2F08%2F13%2FRequireJs%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[RequireJs和AMD规范模块化编程相关笔记文档：https://github.com/amdjs/amdjs-api/wiki/AMD RequireJS简介 RequireJS是一个JavaScript模块加载器。它非常适合在浏览器中使用。它是一个工具库，主要用于客户端的模块管理，当然也可以应用于服务器端，例如Node.js中。RequireJS模块管理遵循AMD规范（Asynchronoous Module Definetion） RequireJS的使用和模块的定义引入require.js 在模块化编程之前，我们需要事先将require.js嵌入网页中，这样就能开始在网页中进行模块化编程了 RequireJS下载地址：http://requirejs.org/ 引入首页面：&lt;script data-main=”js/main” src=”js/require.js”&lt;/script（data-main属性指定主代码所在的脚本文件，也就是从哪里开始，项目所有javascript的入口文件，该属性不可以省略）这里js文件夹下面的main.js是用户指定的入口文件。 define方法定义模块 define方法用于定义一个模块，对于RequireJS来说，要求每一个模块都放在一个独立的文件里面，按照是否依赖其它的模块，定义的模块分为两种： 定义独立模块（独立模块不需要依赖于其它的模块） 12345678910111213141516//一个独立模块，不需要依赖任何其它模块，可以直接使用define方法生成//写法一：定义一个拥有两个方法的模块，define里面定义一个拥有方法的对象define(&#123; method1:function()&#123;&#125;, method2:function()&#123;&#125;&#125;);//写法二：定义一个拥有两个方法的模块，把对象写成一个函数，函数返回值就是输出的模块，define里面定义一个返回模块的函数function，这种自由度更高，可以在函数里面写一些初始化方法define(function()&#123; return &#123; method1:function()&#123;&#125;, method2:function()&#123;&#125; &#125;&#125;);//define定义的模块可以返回任何的值，不限于对象 定义非独立的模块（依赖其它的模块，定义模块必须采用如下进行定义） 1234567891011121314151617181920212223//如果是非独立模块，必须采用如下进行定义define(['module1','module2','module3'],function(mu1,mu2,mu3)&#123; return &#123; method:function()&#123; mu1.method1(); mu2.method2(); mu3.method3(); &#125; &#125;&#125;)//define方法的第一个参数是一个数组，里面是当前模块所依赖的模块，上面代码中表示当前模块依赖3个模块，只有先加载这三个模块，当前模块才能正常的运行。//一般情况下，module1,module2,module3是指当前目录下面的module1.js和module2.js和module3.js文件['module1','module2','module3']等价于['./module1','./module2','./module3']//define方法的第二个参数是一个函数，当前面的所有成员加载成功以后，该函数将会被调用，函数参数与数组成员一一对应，函数必须返回一个对象，以供其它模块的调用。//上面的代码表示模块返回一个对象，该对象的method方法就是外部调用的接口，method方法内调用了module1、module2、module3的方法。//如果一个模块的依赖模块过多，参数与模块一一对应非常麻烦，为了避免繁琐的写法，RequireJS提供一种更加简单的定义模块的方法define(function(require)&#123; var module1 = require("module1"); module2 = require("module2"); module3 = require("module3"); module4 = require("module4"); .......&#125;); require方法：调用模块 require方法用于调用模块，参数与define方法类似 12345require(['module1','module2'],function(module1,module2)&#123; //调用方法&#125;);//上面方法表示加载两个模块，如果模块都加载成功以后，就执行回掉方法 require的第一个参数就是表示一个依赖关系的数组，这个数组可以写的很灵和 12345require([window.JSON ? undefine:'util/json2'],function(json)&#123; JSON = JSON || window.JSON; console.log(JSON.parse('&#123;"JSON":"HERE"&#125;'));&#125;);//上面的代码就写的很灵活，首先判定浏览器是否支持原生JSON如果支持，传入undefine否则就是用工具包util目录下面的json2模块 require方法可以用在define方法内部 1234567891011121314151617define(function(require)&#123; var module = require("module");&#125;);//动态加载模块define(function(require)&#123; var isReady = false,foobar; require(["module1","module2"],function(module1,module2)&#123; isReady=true; foobar = module1() + module2(); &#125;); return &#123; isReady:isReady, foobar:foobar &#125;&#125;); 一个输出Promise对象的例子，可以在该对象的then方法指定下一个动作 12345678require(['lib/Deferred'],function(Deferred)&#123; var defer = new Dferred(); require(['lib/templates/?index.html','lib/data/?stats'],function(templates,data)&#123; //成功后，通过defer来处理，调用defer.resolve后，Promise的状态变为fullfilled已处理 defer.resolve(&#123;template:template,data:data&#125;); &#125;); return defer.promise();&#125;); require方法允许第三个参数，即处理错误的回掉函数，接收一个error对象作为参数 12345require(["module"],function(module)&#123; //加载成功的时候回掉函数&#125;,function(error)&#123; //错误回掉函数&#125;); require对象还允许指定一个全局的Error事件监听函数，所有没有被上面的方法捕获的错误，都会触发onError 123requirejs.onError = function()&#123; //......&#125; 配置require.js：config方法 require方法本身也是一个对象，拥有一个config方法，用来配置require.js运行参数。config方法接收一个对象作为参数。 123456789//require的config方法接收一个对象作为参数require.config(&#123; paths:&#123; jquery:[ '//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.0/jquery.min.js', 'lib/jquery.min.js' ] &#125;&#125;); 配置模块路径的时候，可以单独使用baseUrl属性指定基准目录，也可以单独使用paths属性指定各个模块的位置，也可以结合baseUrl和paths使用 config方法参数对象的属性如下： paths属性 paths参数指定各个模块的位置，位置可以是同一个服务器上的相对位置，也可以是外部网址，他的作用就是将一些常用的js文件，换成通用的名字，如前面的就是将lib/jquery.min.js等换成jquery。可以为每个模块定义多个位置，如果第一个位置加载失败，则加载第二个位置，上面的示例就表示如果CDN加载失败，则加载服务器上的备用脚本。需要注意的是，指定本地文件路径时，可以省略文件最后的js后缀名。 1234//加载jquery模块，因为jquery的路径已经在paths参数中定义了，所以会到事先设定的位置下载require(["jquery"], function($) &#123; // ...&#125;); baseUrl属性 baseUrl参数指定本地模块位置的基准目录，也就是本地模块路径相对于哪一个目录，它的作用就是，以它作为基础路径，在这个路径之下，查找文件（baseUrl 要求所有的js文件都放在同一个文件夹目录下，不然就会报错）。该属性通常由require.js加载时的data-main属性指定。 shim属性 有些库不是AMD兼容的，这个时候就需要指定shim属性的值。shim可以理解为”垫片”，帮助require.js加载非AMD规范的库。 12345678910111213141516171819require.config(&#123; paths:&#123; "backbone":"vendor/backbone", "underscore":"vendor/underscore" &#125;, shim:&#123; "backbone":&#123; //指定依赖 deps:["underscore"], //指定输出符号 exports:"Backbone" &#125;, "underscore":&#123; //指定输出符号 exports:"_" &#125; &#125;&#125;);//上面代码中的backbone和underscore就是非AMD规范的库。shim指定它们的依赖关系（backbone依赖于underscore），以及输出符号（backbone为“Backbone”，underscore为“_”）。 requirejs插件 RequireJS允许使用插件，加载各种格式的数据。 插入文本数据使用的text插件例子 1234define(['module1','text!templates.html'],function(module1,templates)&#123; &#125;);//上面代码加载的第一个模块是module1，第二个模块是一个文本，用'text!'表示。该文本作为字符串存放在回掉函数的templates变量中。 优化器 r.js RequireJS提供一个基于node.js的命令行工具r.js，用来压缩多个js文件。它的主要作用是将多个模块文件压缩合并成一个脚本文件，以减少网页的HTTP请求数。 使用步骤： 第一步安装r.js（如果已经安装node.js）:运行 npm install -g requirejs 然后使用命令：node r.js -o &lt;arguments（arguments表示命令运行的时候所需要的一系列参数，例如） node r.js -o baseUrl= . name=main out=main-build.js 除了命令行提供参数设置，也可以将参数写入一个文件，假定文件名称为build.js 12345（&#123; baseUrl:&quot;.&quot;, name:&quot;main&quot;, out:&quot;main-build.js&quot;&#125;） 然后在用r.js运行这个参数文件，就可以了不需要其它步骤了。 node r.js -o build.js 下面是一个范例，位置在根目录下面，文件名为build.js： 123456789101112131415161718192021222324252627282930313233343536(&#123; appDir: './', baseUrl: './js', dir: './dist', modules: [ &#123; name: 'main' &#125; ], fileExclusionRegExp: /^(r|build)\.js$/, optimizeCss: 'standard', removeCombined: true, paths: &#123; jquery: 'lib/jquery', underscore: 'lib/underscore', backbone: 'lib/backbone/backbone', backboneLocalstorage: 'lib/backbone/backbone.localStorage', text: 'lib/require/text' &#125;, shim: &#123; underscore: &#123; exports: '_' &#125;, backbone: &#123; deps: [ 'underscore', 'jquery' ], exports: 'Backbone' &#125;, backboneLocalstorage: &#123; deps: ['backbone'], exports: 'Store' &#125; &#125;&#125;) 上面代码将多个模块压缩为一个main.js 文件配置属性解释： appDir：项目目录，相对于参数文件的位置。 baseUrl：js文件的位置。 dir：输出目录。 modules：一个包含对象的数组，每个对象就是一个要被优化的模块。 fileExclusionRegExp：凡是匹配这个正则表达式的文件名，都不会被拷贝到输出目录。 optimizeCss: 自动压缩CSS文件，可取的值包括“none”, “standard”, “standard.keepLines”, “standard.keepComments”, “standard.keepComments.keepLines”。 removeCombined：如果为true，合并后的原文件将不保留在输出目录中。 paths：各个模块的相对路径，可以省略js后缀名。 shim：配置依赖性关系。如果某一个模块不是AMD模式定义的，就可以用shim属性指定模块的依赖性关系和输出值。 generateSourceMaps：是否要生成source map文件。 更多信息看官方文档https://github.com/requirejs/r.js/blob/master/build/example.build.js 另一个build.js的例子 123456789101112131415161718(&#123; mainConfigFile : &quot;js/main.js&quot;, baseUrl: &quot;js&quot;, removeCombined: true, findNestedDependencies: true, dir: &quot;dist&quot;, modules: [ &#123; name: &quot;main&quot;, exclude: [ &quot;infrastructure&quot; ] &#125;, &#123; name: &quot;infrastructure&quot; &#125; ]&#125;) 上面代码将模块文件压缩合并成两个文件，第一个是main.js（指定排除infrastructure.js），第二个则是infrastructure.js。 摘自 《JavaScript标准参考教程(alpha)》 by阮一峰]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git使用命令集锦]]></title>
    <url>%2F2018%2F08%2F13%2Fgit%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[1.安装篇 （1）windows上面使用git直接到官网下载git安装程序，完成后开始菜单中git-&gt;git bash如果能弹出，安装成功。 （2）自报家门，打开git bash，然后配置用户名和邮箱（github注册的） git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;youEmail@xx.com&quot; （3）git config 命令的–global参数，表示这台机器上面的所有GIT仓库都会使用这个配置，也可一对某个指定的仓库使用不同的用户名和Email地址。 2.查看配置信息，要检查已有的配置信息，可以使用 git config --list 或者使用 git config -l 3.也可以直接查看某个环境变量的设定（只需要把特定的名字跟在后面） git config user.name 4.要了解git各式工具怎么用，可以阅读使用帮助，例如查看config 命令怎么使用 git help config 5.查看git的版本 git version 6.创建文件夹 mkdir 文件夹名称 7.显示当前目录 pwd 8.查看文件 cat 文件名 9.清空git暂存区 git rm -r --cached 10.打开文件并编辑（打开编辑器） vi 文件名称（或者 vim 文件名称） 11.创建.gitignore文件 （1）进入根目录 （2）touch .gitignore 生成“.gitignore”文件 （3）在.gitignore文件中输入要忽略的文件夹或者文件,例如忽略test文件夹：test/ 12.将文件夹变为git仓库（初始化一个git仓库） git init 13.git init在当前目录下面生成.git目录，用来跟中管理版本库，默认是隐藏的，查看命令如下 ls -ah 14.把文件添加到仓库暂存区进行跟踪（是指从工作空间添加到暂存区保存） git add 文件名 14.跳过添加到暂存区，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，跳过 git add 步骤 git commit -a -m &quot;提交备注&quot; 15.强制把文件添加到git中 git add -f 文件名称 16.把文件提交到仓库 git commit -m &quot;提交备注&quot; 17.查看仓库当前状态（会显示哪些改变的，哪些没有跟踪的，哪些需要提交的） git status 18.要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff git diff 19.查看已经暂存起来的变化（比较的是工作目录中和暂存区域快照之间的差异） git diff --cached（高版本支持git diff --staged） 20.显示从最近到最远的提交日志，查看历史记录 git log（格式化加上 –pretty=oneline 参数后更好看,git log --pretty=oneline）每次提交一个版本，实际上Git就会把他们自动串成一条时间线。 21.查看分支合并图 git log --graph 22.git log加入如下参数查看分支合并情况（以一个图的方式展现出来） git log --graph --pretty=oneline --abbrev-commit 23.git的版本回退 git reset --hard commit_id 24.版本回退到上一个版本 git reset --hard HEAD^ 这条命令会把你工作目录中所有未提交的内容清空(当然这不包括未置于版控制下的文件 untracked files). 从另一种角度来说, 这会让”git diff” 和”git diff –cached”命令的显示法都变为空. 25.回退到上上一个版本 git reset --hard HEAD^^ 26.回退到前100个版本 git reset --hard HEAD~100 27.指定到某个版本 git reset --hard 版本号（版本号是要给生成的hash值，不用写全，可以只是一部分，一般是前面6位数） 28.git 查看每一次命令记录(在找commit id的时候非常有用，查找需要恢复的版本号) git reflog 29.丢弃工作区的修改（也就是回退一个文件，前面的git reset –hard ***是回退整个工作空间，慎用） git checkout -- 文件名 30.暂存区的修改撤销掉（unstage），重新放回工作区(HEAD表示最新版本) git reset HEAD file 31.当使用git reset –hard **，时候丢失了文件（这个是指的是，我们执行了git add .的文件，但是还没有git commit 的文件）的找回办法（当然，如果我们空间里面没有跟踪的文件，那就是gg了，真的丢了，所以尽量要git add .，然后需要的时候git commit一下）原文（我没试过，记录一下，万一遇到了呢） 123git fsck --lost-found //找回git add过但是已经不存在文件中的内容然后找到.git/lost-found/other这个路径下的文件将这些文件拷贝到一个其他的地方，然后通过sublime或者其它的编辑器，查看文件，根据文件的里面的内容从新命名。 32.删除一个文件 git rm 文件名git commit -m &quot;&quot;(使得删除生效，版本库中也被删除) 33.删除一个文件，如果该文件已经被添加到了暂存区，并且这个时候文件被修改，删除需要强制删除 git rm 文件名 -f 34.想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中,仅是从跟踪清单中删除 git rm --cached 文件名称 后面可以列出文件或者目录的名字，也可以使用 glob 模式 git rm log/\*.log 注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开，实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 log/ 目录下扩展名为 .log 的文件。 git rm log \*~ （会递归删除当前目录及其子目录中所有~结尾的文件） 35.把本地仓库与git服务器仓库关联 git remote add 分支名称 git仓库地址例子：git remote add origin https://github.com/LQ55/gitstudy.git（名为origin）本地仓库与github仓库的origin分支建立关联例子： git remote add gitteee https://github.com/LQ55/gitstudy.git(名字为gitteee) 36.把本地库的内容推送到远程，用git push命令，实际上就是把当前分支master推送到远程 结构为：git push origin [本地分支名]:[远程分支名] git push（是push当前分支到当前分支的追踪关系分支 ，一般本地为master分支，push到远程仓库的master分支） git push -u origin master 37.移除远程仓库 git remote rm 仓库名称,例如git remote rm origin 38.重命名远程仓库 git remote rename 原始仓库名 现在仓库名，例如git remote rename orgin ddd306ddd 39.克隆一个本地库 git clone git仓库地址 40.希望在克隆的时候，自己定义要新建的项目名称，可以在后面指定新名称。 git clone git仓库地址 newName（和上面的差别就是，现在文件名为newName，而不是仓库地址对应的名字） 41.git创建分支 git branch 分支名称 42.切换分支 git checkout 分支名称 44.加入参数-b表示创建并切换分支 git checkout -b 分支名称 45.git删除分支 git branch -d 分支名称 46.git强行删除分支（某些时候，开发了并没有用，需要将当前分支，并且当前分支还没有合并） git brach -D 分支名称 47.查看当前分支(git branch会列出所有分支，当前分支前面会有一个*符号) git branch 48.查看当前详细分支信息（可看到当前分支与对应的远程追踪分支） git branch -vv 49.合并指定分支到当前分支 git merge 分支名称 50.保存当前工作现场，等以后恢复现场继续工作 git stash 51.回到分支以后查看保存的分支现场（列表展示） git stash list 52.恢复分支现场 (1)git stash apply (恢复后stash内容 并不会删除需要 git stash drop 删除)(2)git stash pop(恢复的同时把stash内容也删除掉) 53.恢复到指定的stash (1)先用git stash list 查看，然后恢复到指定的stash(2)git stash apply stash@{0} 53.根据名字删除stash (1)先用git stash list 查看，然后删除指定的stash (2)git stash drop stash@{0} 也可以使用 git stash clear 命令一次性删除所有缓存的stash 54.查看远程库的信息 git remote 55.查看更佳详细的远程库信息 git remote -v(查看到可以抓取和推送的origin地址，没有推送权限看不到push地址) 56.推送指定分支到分支到远程 git push origin 分支名称 57.使用强制push方法发（这样会覆盖远程分支，丢失修改） push -u origin master -f 58.创建远程origin的dev分支到本地 git checkout -b dev origin/dev 59.设置本地分支跟踪服务器的远程某个分支，可以使用如下命令 git branch -u remote-name/branch-name branch-name 或者使用 git branch --set-upstream remote-name/branch-name branch-name 例如设置本地master分支跟踪服务器的dev分支，使用如下 git branch --set-upstream orign/dev master 使用上面的将本地分支关联到远程分支后，以后在此分支上面的推送将会是推送到远程关联的分支上面（通常这种在开发的时候，就是远程一个开发分支关联到本地分支，本地推送到远程开发分支以后，然后将远程的开发分支合并到远程的master分支） 60.抓取远程分支最新内容到本地 git pull (有时候抓取以后有冲突，需要手动解决，该命令相当于git fetch + git merge) 61.打新标签（Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。 ） git tag 标签名字 62.查看所有标签 git tag 63.对指定commit打标签 (1)先git log --pretty=oneline --abbrev-commit查看历史提交的commit id(2)git tag 标签名称 commit-id 64.查看标签信息 git show 标签名称 65.创建带有说明的标签，用-a指定标签名，-m指定说明文字 git tag -a 标签名 -m “说明文字” 66.删除标签 git tag -d 标签名称 67.推送某个标签到远程 git push origin 标签名称 68.一次性推送全部尚未推送到远程的本地标签 git push origin --tags 69.删除已经推送到远程的标签 (1)先删除本地标签 git tag -d 标签名称(2)删除远程标签 git push origin :refs/tags/标签名70.查看远程分支git branch -r 或者 git branch -a71.查看远程分支详情git branch -r -v 或者 git branch -a -v72.删除远程分支(1)git branch -r -d origin/分支名称(2)git push origin :分支名称 73.移动文件 git mv file_from file_to 74.git设置文件上传的上限（遇到&gt;100M的文件上传失败）=====&gt;失败了 git config --global http.postBuffer 524288000（设置http.postBuffer为500M，上限为500M） 75.查看配置（全局与局部和系统） git config --global --list（查看全局配置） git config --local --list（查看局部配置） git config --system --list（查看系统配置） (2018-3-7修订)]]></content>
      <categories>
        <category>GIT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[资源链接]]></title>
    <url>%2F2018%2F08%2F13%2FREADME%2F</url>
    <content type="text"><![CDATA[前端书籍精粹（JavaScript、html）等。前端书籍下载 深入理解javascript系列（汤姆大叔）。汤姆大叔深入理解javascript系列]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5之FileReader API的使用]]></title>
    <url>%2F2018%2F08%2F13%2FHTML5%E4%B9%8BFileReader%20API%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[HTML5之FileReader API的使用简介 FileReader 对象允许Web应用程序异步读取存储在用户计算机上面的文件（或者原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。其中File对象可以是来自用户在一个input元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。 FileReader的构造函数 FileReader，通过new FileReader()返回一个新构造的FileReader。 FileReader的属性和描述 属性 访问性 说明 FileReader.error 只读 表示在读取文件时发生的错误 FileReader.readyState 只读 表示FileReader状态的数字，取值如下：常量名 值 描述EMPTY 0 还没有加载任何数据。LOADING 1 数据正被加载DONE 2 已完成全部的读取请求 FileReader.result 只读 文件的内容，该属性仅仅在读取操作完成以后才有效，数据格式取决于使用哪种方法来启动读取操作。 FileReader的事件处理 FileReader继承自EventTarget，因此所有下面的事件都可以通过addEventListener方法使用。 事件 说明 FileReader.onbort 处理abort事件。该事件在文件读取操作被中断时触发。 FileReader.onerror 处理error事件。该事件在读取操作发生错误时触发。 FileReader.onload 处理load事件。该事件在读取操作完成时触发。 FileReader.onloadstart 处理loadstart事件。该事件在读取操作开始时触发。 FileReader.onloadend 处理loadend事件。该事件在读取操作结束时（要么成功，要么失败）触发。 FileReader.onprogress 处理progress事件。该事件在读取Blob时触发。 FileReader的方法 方法 说明 FileReader.abort() 终止读取操作。在返回的时候，readyState属性为DONE FileReader.readAsArrayBuffer() 开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象. FileReader.readAsBinaryString() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。 FileReader.readAsDataURL() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容。 FileReader.readAsText() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。 readAsText：方法有两个参数，其中第二个参数是文本的编码格式，默认值为UTF-8。这个方法是将文件以文本方式读取，结果是文本文件中的内容。 使用：示例（加载计算机中的图片展示到页面上） 123456789101112131415161718192021222324252627&lt;div&gt; &lt;div class="headImg"&gt; &lt;input type="file" style="visibility: hidden" id ="headFile" onchange="loadImage()"/&gt; &lt;img onclick="trigerFileInput()" style="hidden;width:35%;height:85px" id="default" src="../img/timg.jpg"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //触发input[type="file"]的选择事件，打开图片选择窗口 function trigerFileInput()&#123; document.getElementById("headFile").click(); &#125; //加载图片 function loadImage()&#123; var file = document.getElementById("headFile").files[0]; var filename = file.name; if(/(\.png|\.jpg)$/.test(filename))&#123; var reader = new FileReader(); reader.onload = function()&#123; document.getElementById("default").src=this.result; &#125; reader.readAsDataURL(file); &#125; else&#123; alert("请选择正确的文件"); &#125; &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6的点滴]]></title>
    <url>%2F2018%2F08%2F13%2FES6%E7%9A%84%E7%82%B9%E6%BB%B4%2F</url>
    <content type="text"><![CDATA[Set 特性 es6中set类似数组，成员值是唯一的，Array.from方法可以将 Set 结构转为数组 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化 一种去除数组重复成员的方法：[…new Set(array)] Set 加入值的时候，不会发生类型转换，Set 内部判断两个值是否不同，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身 另外，两个对象总是不相等的：set.add({}); set.add({}); set.size // 2 实例的属性和方法 属性： Set.prototype.constructor：构造函数，默认就是Set函数 Set.prototype.size：返回Set实例的成员总数 方法（操作方法）： add(value)：添加某个值，返回 Set 结构本身 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功 has(value)：返回一个布尔值，表示该值是否为Set的成员 clear()：清除所有成员，没有返回值 方法（遍历方法）： keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法，意味着，可以省略values方法，直接用for...of循环遍历 Set WeakSet WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。WeakSet 里面的引用，都不计入垃圾回收机制。 Map 特性 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组new Map([ [‘name’, ‘张三’], [‘title’, ‘Author’]]) 不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数 同一个键多次赋值，后面的值将覆盖前面的值，读取一个未知的键，则返回undefined 只有对同一个对象的引用，Map 结构才将其视为同一个键 只要两个值严格相等，Map 将其视为一个键，虽然NaN不严格相等于自身，但 Map 将其视为同一个键 实例的属性和方法 size属性返回 Map 结构的成员总数 set方法设置键名key对应的键值为value，然后返回整个 Map 结构 get方法读取key对应的键值，如果找不到key，返回undefined has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中 delete方法删除某个键，返回true。如果删除失败，返回false clear方法清除所有成员，没有返回值 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回所有成员的遍历器 forEach()：遍历 Map 的所有成员 Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历 需要特别注意的是，Map 的遍历顺序就是插入顺序。Map 结构转为数组结构，比较快速的方法是使用扩展运算符。 如果所有 Map 的键都是字符串，它可以无损地转为对象 WeakMap WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名,WeakMap的键名所指向的对象，不计入垃圾回收机制]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BEM学习总结]]></title>
    <url>%2F2018%2F08%2F13%2FBEM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[What is BEM？BEM：Block（块） Element（元素） Modfier（修饰符），是由Yandex团队提出的一种前端命名方法论。根据这个规范，能够创建出可以复用的前端组件和前端代码。（BEM是一个高可用、强大的、简单易用的命名规范） 编程方法论中常见的一个就是面向对象编程（OOP），这种方法用在了许多的语言中。BEM和OOP类似的，是用代码和一系列模式来描述实际情况的方法，只考虑程序实体而无所谓使用什么编程语言。（摘自https://www.w3cplus.com/css/bem-definitions.html）命名规范 Why Choose BEM?除了BEM规范以外还有其它的规范例如： OOCSS：用CSS“对象”分隔容器和内容 SMACSS：风格指南为您的CSS编写CSS规则的五个类别 SUITCSS：结构化类名和有意义的连字符 原子：将样式分解为原子或不可分割的部分 上面的方法都可以应用在项目中，无论使用哪一种方法，都将受益于更多结构化CSS和UI的优势。一些风格不那么严格和更灵活，而另一些则更容易理解和适应团队。 使用的原因：它比其他方法（即SMACSS）更容易混淆，但仍为我们提供了我们想要的良好体系结构（即OOCSS）以及可识别的术语。 （摘自https://www.jianshu.com/p/339fdb93e155） Features 简单易用：只需要采用BEM命名规范就可以 单元性：独立的块和CSS选择器，可以使得你的代码可以重用和单元化 灵活性：使用BEM之后，方法和工具可以按照自己喜欢的方式进行配置（XML 、JSON） 按组件划分类名，减少层次关系，实现扁平化、语义化，通过唯一的类名来避免不必要的样式继承，提高渲染效率。 How To Use?BEM命名规范参见BEM官网：http://getbem.com/naming/ 部分摘自https://segmentfault.com/a/1190000012705634 Block 命名规范：block-name 示例： 1234.block&#123;&#125;.container&#123;&#125;.blog-header&#123;&#125;/*上面都是block的命名方式，其中第三个是block名字有多个单词组成使用-隔开*/ Block是逻辑和功能相对独立的单元，类似于组件。每个block包含自己的行为（js）、结构（html模板）、表现（css）。block的独立性有利于代码的复用，有利于项目的管理。 （1）block名描述block功能，不能包含其状态，block可以嵌套、复用 描述功能就是描述这个block是干什么的？例如menu、carboard等等 不能包含其状态就是不能描述它的表现，例如一个button，那么不能描述它是什么样子red，blue 1234&lt;!--正确的写法--&gt;&lt;div class="error"&gt;&lt;/div&gt;&lt;!--错误的写法，block包含了状态--&gt;&lt;div class="red-text"&gt;&lt;/div&gt; 嵌套的block 1234&lt;div class="header"&gt; &lt;div class="logo"&gt;&lt;/div&gt; &lt;div class="search-form"&gt;&lt;/div&gt;&lt;/div&gt; block不能够影响自身的布局，就是不能为block设置margin和position属性 不能在BEM中使用元素选择器和ID选择器 Element（element只能作为block的一部分使用，不能独立使用） 命名规范：block-name__element-name（中间的-是名字如多个单词，使用的-连接） 示例： 12.block__mod&#123;&#125;.block-body__mod&#123;&#125; 一个元素是块的一部分，具有某种功能。元素是依赖上下文的：它们只有处于他们应该属于的块的上下文中时才是有意义的。 element表示其目的（item,text…..）,不是描述他的状态 命名格式为：block-name__element-name，其中的element名字和block名字以双下划线分开 12345&lt;form class="search-form"&gt; &lt;!--下面的`input`element在`search-form`block之中--&gt; &lt;input class="search-form__input"/&gt; &lt;button class="search-form__button"&gt;搜索&lt;/button&gt;&lt;/form&gt; elements同样可以相互嵌套，数量不限 1234567&lt;!-- 正确. 下面整个element命名符合规范:`block-name__element-name`--&gt;&lt;form class="search-form"&gt; &lt;div class="search-form__content"&gt; &lt;input class="search-form__input"/&gt; &lt;button class="search-form__button"&gt;&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 123456789&lt;!--不正确的示例，下面的element命名不符合规范：`block-name__element-name`--&gt;&lt;form class="search-form"&gt; &lt;div class="search-form__content"&gt; &lt;!-- Recommended: `search-form__input` or `search-form__content-input` --&gt; &lt;input class="search-form__content__input"&gt; &lt;!-- Recommended: `search-form__button` or `search-form__content-button` --&gt; &lt;button class="search-form__content__button"&gt;Search&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; block决定了命名空间，确保elements不被其他block影响。block中的element在css中不需要跟block一起使用，而是独立的定义规则，这样当修改block结构的时候不需要修改css。示例如下： 123456789101112131415161718192021&lt;style&gt; .block&#123;&#125; .block__elem1&#123;&#125; .block__elem2&#123;&#125; .block__elem3&#123;&#125;&lt;/style&gt;&lt;!--未修改之前--&gt;&lt;div class="block"&gt; &lt;div class="block__elem1"&gt; &lt;div class="block__elem2"&gt; &lt;div class="block__elem3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--修改结构，element的规则和他们的命名依然保持不变--&gt;&lt;div class="block"&gt; &lt;div class="block__elem1"&gt; &lt;div class="block__elem2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="block_elem3"&gt;&lt;/div&gt;&lt;/div&gt; When to use element?When to use block? block：如果一段代码可以重用，而不依赖于正在执行的其他页面组件。这个时候使用block element：如果一段代码不能脱离父模块独立存在，那么使用element Modifier 命名规范： 有值block-name__element-name--modifier-value，block-name--modifier-value 无值block-name__element-name--modifier，block-name--modifier 示例： 1234.block__elem--mod&#123;&#125;/*这个是没有值的修饰符*/.block__elem--mod-value&#123;&#125;/*这是修饰符带有值，带有值的修饰符通过-将修饰符和值隔开key-value形式*/.block--mod&#123;&#125;/*这个是对块的描述，不带值*/.block--mod-value&#123;&#125;/*这个是对块的描述，带有值*/ Modifier定义block和element的外观，状态或者行为。 表示表现（“What size? ” or “Which theme?” and so on — size_s or theme_islands)， 表示状态(“How is it different from the others?” — disabled, focused, etc. ) 表示行为(“How does it behave?” or “How does it respond to the user?” — such as directions_left-top ) modifier的类型为Boolean例子（带有值）： 123456&lt;!-- The `search-form` block has the `theme` modifier with the value `islands` --&gt;&lt;form class="search-form search-form--theme-islands"&gt; &lt;input class="search-form__input"/&gt; &lt;!-- The `button` element has the `size` modifier with the value `m` --&gt; &lt;button class="search-form__button search-form__button--size-m"&gt;&lt;/button&gt;&lt;/form&gt; modifier的类型为key-value的例子： 1234567&lt;form class="search-form search-form_theme_islands search-form_theme_lite"&gt; &lt;!-- The `input` elemen --&gt; &lt;input class="search-form__input"/&gt; &lt;button class="search-form__button search-form__button--size-s search-form__button--size-m"&gt; &lt;/button&gt;&lt;/form&gt; modifier不能够单独使用 123456789101112131415&lt;!-- Correct. The `search-form` block has the `theme` modifier with the value `islands`--&gt;&lt;form class="search-form search-form--theme-islands"&gt; &lt;input class="search-form__input"&gt; &lt;button class="search-form__button"&gt;Search&lt;/button&gt;&lt;/form&gt;&lt;!-- Incorrect. The modified class `search-form` is missing --&gt;&lt;form class="search-form--theme-islands"&gt; &lt;input class="search-form__input"&gt; &lt;button class="search-form__button"&gt;Search&lt;/button&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AMD规范笔记]]></title>
    <url>%2F2018%2F08%2F13%2FAMD%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[AMD翻译自：https://github.com/amdjs/amdjs-api/blob/master/AMD.md 异步模块定义（AMD）API指定用于定义模块的机制，使得模块及其依赖项可以异步加载。这个特别适合与浏览器环境，其中模块的同步加载会导致（incurs ）性能、可用性、调试、和跨域访问等问题。 API 说明（API specification）define() 方法该规范定义了一个自由变量或者叫做一个全局的变量”define”作为一个方法，方法的结构如下： define(id?,dependencies?,factory) 第一个参数id是一个string类型的，它用来指明（specifies）当前被定义的模块，这个参数是可选的（optional），如果它不存在，模块ID应该默认为加载程序请求给定响应脚本的模块的ID。当存在时，模块ID必须是“顶级”或绝对ID（相对ID是不允许的）]]></content>
      <categories>
        <category>前端相关技术</category>
      </categories>
  </entry>
</search>
